/*! bit-imports v2.0.5 - Wed Jun 15 2016 12:59:12. (c) 2016 Miguel Castillo. Licensed under MIT */
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.bitimports=a()}}(function(){var define,module,exports;return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){var d=a("./src/fetcher"),e=a("./src/resolver"),f=a("./src/factory");f.register("fetcher",d),f.register("resolver",e),b.exports=a("./src/bit-imports").create({doNotIgnoreNodeModules:!1})},{"./src/bit-imports":61,"./src/factory":62,"./src/fetcher":63,"./src/resolver":65}],2:[function(a,b,c){/**
 * Build and file object with the important pieces
 */
function d(a){var b,c=a.replace(/([^\/]+)$/gim,function(a){return b=a,""});return{name:b||"",directory:c,path:a}}/**
 * Method to add an extension if one does not exist in the fileString.  It does NOT replace
 * the file extension if one already exists in `fileString`.
 *
 * @param {string} fileString - File string to add the extension to if one does not exist
 * @param {string} extension - Extension to add if one does not exist in `fileString`. The
 *   value is the extension without the `.`. E.g. `js`, `html`.  Not `.js`, `.html`.
 * @returns {string} New fileString with the new extension if one did not exist
 */
function e(a,b){var c=d(a),e=c.name.split(".");return 1===e.length&&b&&e.push(b),c.directory+e.join(".")}/**
 * Method that gets the extension from a file path
 *
 * @param {string} fileString - File path to get the extension for.
 *
 * @returns {string} File extension
 */
function f(a){var b=a.match(/[^.\/\\]+\.([^.]+)$/);return b&&b[1]||""}/**
 * Method to replace an extension, if one does not exist in the file string, it will be added.
 *
 * @param {string} fileString - File string to add the extension to if one does not exist
 * @param {string} extension - Extension to be either added to `fileString` or to replace the extension in `fileString`. The
 *   value is the extension without the `.`. E.g. `js`, `html`.  Not `.js`, `.html`.
 * @returns {string} fileString with the new extension
 */
function g(a,b){var c=/([^.\/\\]+\.)[^.]+$/;return c.test(a)?a.replace(c,"$1"+b):a+"."+b}b.exports={parseParts:d,addExtension:e,getExtension:f,replaceExtension:g}},{}],3:[function(a,b,c){/**
 * @constructor
 * Provides a way to build a module meta object from a module name.  The resolution
 * relies on configuration settings, which are compatible with requirejs. The created
 * module meta objects contain information such as a url that can be used for downloading
 * the corresponding file from a remote sever.
 */
function d(a){a=a||{};var b=a.baseUrl||".";
// Make sure that if a baseUrl is provided, it ends in a slash.  This is to ensure
// proper creation of URLs.
b&&"/"!==b[b.length-1]&&(b+="/");for(var c in g)this[c]=a.hasOwnProperty(c)?a[c]:g[c];this.baseUrl=b}var e=a("./file"),f=a("./url"),g={urlArgs:"",shim:{},packages:[],paths:{},extensions:[]};/**
 * Creates a module meta from a module name/id.
 *
 * @param {string} name - Module name/id
 * @param {string} baseUrl - base url to be used when the `name` starts with `./`, `../`, or a protocol.
 *   Otherwise the configured baseUrl is used.
 *
 * @returns {{name: string, file: File, urlArgs: string, shim: object}}
 */
d.prototype.resolve=function(a,b){var c,g,h,i,j,k,l,m,n,o=this.shim,p=this.packages,q=this.paths,r=q[a],s=a.split("!");
// Go through the packages and figure if the module is actually configured as such.
for(a=s.pop(),j=a.replace(/[\/\\]+/g,"/").split("/"),k=j.shift(),l=j.join("/"),c=0,g=p.length;g>c;c++){if(i=p[c],i===k){r=k+"/main";break}if(i.name===k){r=i.location&&i.location+"/"||"",r+=k+"/"+(l||i.main||"main");break}}
// Get the extension to determine if we need to add the `js` extension or not.
// Let's assume .js extension for everything that is not for a plugin
// or a known extension
return o.hasOwnProperty(a)&&(m={name:o[a].exports||o[a].name||a,deps:o[a].imports||o[a].deps||[]}),r||(r=a),h=e.getExtension(r),0===s.length&&"js"!==h&&-1===this.extensions.indexOf(h)&&(r+=".js"),b=d.useBase(r)&&b?b:this.baseUrl,n=new f(this.urlArgs?r+"?"+this.urlArgs:r,b),{name:a,url:n,shim:m,plugins:s}},/**
 * Checks and returns true if name starts with `./`, `../`, or a protocol.  Otherwise returns false;
 */
d.useBase=function(a){return"."===a[0]&&("/"===a[1]||"."===a[1]&&"/"===a[2])||d.hasProtocol(a)},/**
 * Quick check to determine if the name has a known protocol. Currently we only support http(s) and file.
 */
d.hasProtocol=function(a){return/^(?:(https?|file)(:\/\/\/?))/g.test(a)},d.file=e,d.Url=f,b.exports=d},{"./file":2,"./url":4}],4:[function(a,b,c){/**
 * Url factory that creates URL object as defined here https://developer.mozilla.org/en-US/docs/Web/API/URL
 *
 * @param {urlString} string - URL string to build a URL object from
 * @param {baseString} string - URL string to use as a base for building the URL object.
 *
 * @returns {object} URL object
 */
function d(a,b){return d.parser.join(b||"",a)}/**
 * Parses out a url, with an optional base url, and returns the fully processed href.
 *
 * @param {string} urlString - URL to be processed
 * @param {string} baseString - Base URL
 *
 * @returns {string} full href
 */
function e(a,b){return d.parser.join(a,b).href}/**
 * Parses out a url string with an optional base url, and returns the fully resolved URL object.
 *
 * @param {string} urlString - URL to be processed
 * @param {string} baseString - Base URL
 *
 * @returns {object} URL object
 */
function f(a,b){var c=g(a),d=g(b),e="";return i.isAbsolute(d.pathname)?e=d.pathname:(c.pathname||d.pathname)&&(e=i.join(h(c.pathname),d.pathname)),!d.hostname&&c.hostname&&(d=c),d.pathname=e,d.href=g.href(d),d}/**
 * Parses out a string and creates a URL object as defined
 * here https://developer.mozilla.org/en-US/docs/Web/API/URL
 *
 * Parses out the username and password from a URL as defined here.
 * https://developer.mozilla.org/en-US/docs/Web/API/URLUtils/username
 * https://developer.mozilla.org/en-US/docs/Web/API/URLUtils/password
 *
 * @param {string} urlString - URL string to be parsed to create a URL object
 * @returns {object} URL object
 */
function g(a){var b=/^((https?:)(\/\/\/?)(?:([\w]+)(?::([\w]*))?@)?([\d\w\.-]+)(?::(\d+))?)?([\/\\\w\.()-]*)?(?:([?][^#]*)?(#.*)?)*/gim.exec(a);b.shift(),
// Make sure we sanitize the slashes and dotted paths
b[5]&&(b[5]=i.normalize(b[5]));var c={origin:b[0]||"",protocol:b[1]||"",delimeter:b[2]||"",username:b[3]||"",password:b[4]||"",hostname:b[5]||"",port:b[6]||"",pathname:b[7]||"",search:b[8]||"",hash:b[9]||""};return c.pathname=g.pathname(c),c.host=g.host(c),c.href=g.href(c),c}/**
 * Processes a pathname and returns only the path. If a file is present
 * then it is removed, otherwise the same string is returned.
 *
 * @returns {string} directory of the pathname
 */
function h(a){if(1!==a.length&&"/"!==a[a.length-1]){var b=a.lastIndexOf("/");return a.substr(0,0===b?1:b)}return a}var i=a("path");/**
 * Parses out the pathname based on whether or not a hostname exists. If a
 * hostname exists then there must always be a path; "/" by default. Otherwise
 * pathname can be empty.
 *
 * @param {object} url - URL object
 * @returns {string} pathname
 */
g.pathname=function(a){return a.hostname?a.pathname||"/":a.pathname},/**
 * Builds a host string.  The host string is defined as the hostname, and if a port
 * is specified, then a ":" and the port number.  Otherwise just the hostname.
 *
 * @param {object} url - URL object
 * @returns {string} Host string
 */
g.host=function(a){return a.hostname+(a.port?":"+a.port:"")},/**
 * Builds the full URL as a string
 *
 * @param {object} url - URL object
 * @returns {string} Full url as a string
 */
g.href=function(a){return a.origin+a.pathname+a.search+a.hash},d.parser={resolve:e,parse:g,join:f},
//
// This chunk of code below enables nodejs URL module.  Useful for testing purposes.
//
//Url.parser = require('url');
//Url.parser.join = function(baseString, urlString) {
//  var resolved = Url.parser.resolve(baseString || "", urlString);
//  var url      = Url.parser.parse(resolved);
//  url.origin   = url.protocol ? (url.protocol + "//" + url.host) : "";
//  url.hash     = url.hash     || "";
//  url.host     = url.host     || "";
//  url.hostname = url.hostname || "";
//  url.password = url.password || "";
//  url.pathname = url.pathname || "";
//  url.port     = url.port     || "";
//  url.protocol = url.protocol || "";
//  url.search   = url.search   || "";
//  url.username = url.username || "";
//  return url;
//};
b.exports=d},{path:58}],5:[function(a,b,c){/**
 * Method that converts a string of object and array keys, which we also
 * refer to as keypath, to an array of keys that can be used for reading
 * nested values in an object.
 */
function d(a){for(var b,c=/(\w+)|\[([^\]]+)\]/g,d=[];b=c.exec(a||"");)"["===a[b.index]?d.push(b[2]):d.push(b[1]);return d}b.exports=d},{}],6:[function(a,b,c){/**
 * Converts array to a literal object with the array values used as keys. So this is
 * to be used for converting an array of string/number entries to a literal object with
 * those values as the keys for the new object.
 *
 * @param { array } input - Items to convert to a map
 * @param { *? } val - Can be a function, in which case it is called with the currect
 *  item in the array being processed in order to derive the value for the map entry.
 *  Otherwise the value will be the same as the value in the array, which will also
 *  be the key.
 *
 * @returns { object } Object will all the array values as keys and the derived
 *  values
 */
function d(a,b){var c=!0;return 1!==arguments.length&&(e.isFunction(b)||(c=b,b=!1)),a.reduce(function(d,e,f){return d[e]=b?b(e,f,a):c,d},{})}var e=a("dis-isa");b.exports=d},{"dis-isa":53}],7:[function(a,b,c){/**
 * Shallow copies all properties from the input objects (sources) into the target
 * object. Source objects are processed left to right overriding whatever values
 * already exist in the resulting.
 *
 * @param {object} target - Object to copy properties to
 * @param {...} source - The source objects to be merged into the target object
 *
 * @returns {object} Object with all source objects merged in.
 */
function d(a){var b,c,d;
// Allow n params to be passed in to extend this object
for(a=a||{},d=1,c=arguments.length;c>d;d++){b=arguments[d];for(var e in b)b.hasOwnProperty(e)&&(a[e]=b[e])}return a}b.exports=d},{}],8:[function(a,b,c){/**
 * Helper method that returns the first argument passed in.
 *
 * @param {*?} input - Argument to be returned. This is completely optional
 *
 * @returns {*} This returns whatever is passed in.
 */
function d(a){return a}b.exports=d},{}],9:[function(a,b,c){var d=a("./pick"),e=a("./omit"),f=a("./extend"),g=a("./merge"),h=a("./identity"),i=a("./noop"),j=a("./objectValue"),k=a("./objectValues"),l=a("./arrayToObject"),m=a("./value");b.exports={result:m,pluck:d,pick:d,omit:e,extend:f,merge:g,identity:h,noop:i,value:m,objectValue:j,objectValues:k,arrayToObject:l}},{"./arrayToObject":6,"./extend":7,"./identity":8,"./merge":10,"./noop":11,"./objectValue":12,"./objectValues":13,"./omit":14,"./pick":15,"./value":16}],10:[function(a,b,c){function d(a,b){return b}function e(a,b){var c;for(var d in b)b.hasOwnProperty(d)&&(c=b[d],g.isBuffer(c)?a[d]=c:c&&c.constructor===Object?(a[d]=a[d]||{},a[d]=e(a[d],c)):g.isArray(c)?(a[d]=a[d]||[],a[d]=e(a[d],c)):a[d]=c);return a}/**
 * Deep copy all properties from the input objects (sources) into the target object.
 * It merges objects and arrays into new structures from left to right overriding
 * already set properties.
 *
 * @param {object} target - Object to copy properties to
 * @param {...object} sources - The list of source objects to be merged into the target object
 * @param {function} transform - Transform function called with current and next value, as well
 *  as the key in order to generate the final value for the particular object entry. The transform
 *  is only called with top level objects currently being processed.
 *
 * @returns {object} Object with all source objects merged in.
 *
 * @example
 *
 * // The result of this is an object with the array entries concatinated
 * // and the exapnded out object property as generated by the transform
 * // method.
 * // {
 * //   data: [1, 2, 3, 4, 5, 6],
 * //   misc: {
 * //     expanded: "modded"
 * //   }
 * // }
 *
 *  var source1 = {
 *    data: [1, 2, 3],
 *    misc: "random"
 *  };
 *
 *  source2 = {
 *    data: [4, 5, 6]
 *  };
 *
 *  result = merge({}, source1, source2, transform);
 *
 * function transform(current, next) {
 *   if (Array.isArray(next.data)) {
 *     return {
 *       data: current.data ? current.data.concat(next.data) : next.data
 *     };
 *   }
 *
 *   return next;
 * }
 */
function f(a){a=a||{};var b=Array.prototype.slice.call(arguments,1),c=d;g.isFunction(b[b.length-1])&&(c=b[b.length-1],b.pop());
// Allow `n` params to be passed in to extend this object
for(var f=0,h=b.length;h>f;f++)e(a,c(a,b[f]));return a}var g=a("dis-isa");b.exports=f},{"dis-isa":53}],11:[function(a,b,c){/**
 * noop method. It takes no arguments and does not return anything. Useful
 * when you need to setup an initial placeholder function.
 */
function d(){}b.exports=d},{}],12:[function(a,b,c){/**
 * Extract values from an input object for a given keypath. This will call any
 * functions along the way of extracting the final value.
 *
 * @param {object} input - Object to read `property` from.
 * @param {string|number|array} keypath - keypath for the value in the object.
 * @param {function?} transform - Function that takes the final value, the resolved keypath, and
 *  the collection. This is a chance for an external function to transform the result before
 *  it is returned.
 *
 * @returns {*} The value for the corresponding keypath.
 */
function d(a,b,c){if(b){g.isString(b)?b=f(b):g.isArray(b)||(b=[b]);
// Find value...
var d=b.reduce(function(a,b){return a[b]},a);return(c||e)(d,b,a)}}var e=a("./identity"),f=a("split-keypath"),g=a("dis-isa");b.exports=d},{"./identity":8,"dis-isa":53,"split-keypath":5}],13:[function(a,b,c){/**
 * Gets the values from a map and returns them in an array. If an array is passed in, then the array is returned as is.
 *
 * @param {object | Array} input - Input to get values from
 *
 * @returns { Array } - Array of all the values extracted from the input object, or
 *  the array itself if the input is an array.
 */
function d(a){return e.isArray(a)?a:Object.keys(a).filter(function(b){return a.hasOwnProperty(b)}).map(function(b){return a[b]})}var e=a("dis-isa");b.exports=d},{"dis-isa":53}],14:[function(a,b,c){/**
 * Method that removes key value pairs from the input object and returns the remaining data
 * in a new shallow copy of the input object.
 *
 * @param { object } input - Object to extract data from
 * @param { string | string[] | object } keys - Keys for the values to extract from the input
 *
 * @returns { object } Object with key value pairs of extracted data.
 */
function d(a,b){return e.isPlainObject(a)?(e.isArray(b)||e.isPlainObject(b)||(b=[b]),e.isArray(b)&&(b=f(b)),Object.keys(a).filter(function(a){return!b.hasOwnProperty(a)}).reduce(function(b,c){return b[c]=a[c],b},{})):{}}var e=a("dis-isa"),f=a("./arrayToObject");b.exports=d},{"./arrayToObject":6,"dis-isa":53}],15:[function(a,b,c){/**
 * Method that extracts key value pairs from the input object and returns that in a new object
 * in a new shallow copy of the input object.
 *
 * @param { object } input - Object to extract data from
 * @param { string | string[] | object } keys - Keys for the values to extract from the input
 *
 * @returns { object } Object with key value pairs of extracted data.
 */
function d(a,b){return e.isPlainObject(a)?(e.isArray(b)||e.isPlainObject(b)?e.isPlainObject(b)&&(b=Object.keys(b)):b=[b],b.filter(function(b){return a.hasOwnProperty(b)}).reduce(function(b,c){return b[c]=a[c],b},{})):{}}var e=a("dis-isa");b.exports=d},{"dis-isa":53}],16:[function(a,b,c){/**
 * Method that uses the input to derive a return value.
 *
 * If the input is a function, then the function is called. If the function returns
 * a value, that value is then returned as the final result. Otherwise, if value is
 * *not* undefined, then that's returned as the final value. Otherwise, the default
 * value is returned.
 *
 * @param {*} input - input value to derived returned value from.
 * @param {array} args - Arguments to be passed into the input when it is a function.
 * @param {*} defaultValue - value to be returned in case the input is not defined.
 *
 * @returns {*} The derived value
 */
function d(a,b,c,d){return e.isFunction(a)&&(a=a.apply(c,b||[])),e.isUndefined(a)?d:a}var e=a("dis-isa");b.exports=d},{"dis-isa":53}],17:[function(a,b,c){function d(a){if(f)switch(a.level){case g.log:f.log(a);break;case g.info:f.log(a);break;case g.warn:f.warn(a);break;case g.error:f.error(a)}}function e(a){return a}var f,g=a("./levels");"undefined"!=typeof console&&(f=console),/**
 * Returns a valid console interface with three methods:
 *
 * @returns {{write: function}}
 */
b.exports={write:d,pipe:e}},{"./levels":19}],18:[function(a,b,c){/**
 * @class
 * Logger instance with a name
 *
 * @param {string} name - Name of the logger
 */
function d(a,b){this.name=a,this._enabled=l(b,"enabled"),this._stream=l(b,"stream"),this._level=l(b,"level");var c=this;k[a]=this,/**
   * Create the logger method for each level. Set it up in the constructor
   * to properly lock in the context.
   */
Object.keys(j).forEach(function(a){c[a]=function(){return c.write(j[a],arguments)}})}/**
 * Function that create a JSON structure to be logged
 *
 * @param {string} name - Name of the logger
 * @param {int} level - Logging level. E.g. log, warn, error
 * @param {object} data - application data to be logged
 *
 * @returns {{date: Date, level: int, name: string, data: object}}
 *  Meta data to be logged
 */
function e(a,b,c){return{date:f(),level:b,name:a,data:c}}/**
 * Helper method to get timestamps for logged message
 *
 * @private
 */
function f(){return(new Date).getTime()}function g(a){return function(b,c){return b&&b.hasOwnProperty(c)?b[c]:a[c]}}var h,i=a("./consoleStream"),j=a("./levels"),k={},l=g({enabled:!0});/**
 * Expose levels to allow the customization of the values if need be.
 * Don't expect this to be a common use case.
 */
d.prototype.levels=j,/**
 * Helper factory method to create named loggers
 *
 * @returns {Logger} New logger instance
 */
d.prototype.create=function(a,b){return k[a]?k[a]:new d(a,b)},/**
 * Method to find a logger instance by name.
 *
 * @param {string} name - Name of the logger to find
 *
 * @returns {Logger}
 */
d.prototype.find=function(a){return k[a]},/**
 * Method to replace the current stream with a new one.
 *
 * @param {Stream} stream - Stream to write data to
 *
 * @returns {Stream} stream passed in
 */
d.prototype.pipe=function(a){return a!==this._stream&&(this._stream=a),a},/**
 * Log a message with a custom `level`
 */
d.prototype.write=function(a,b){return a=a||j.info,this.isEnabled(a)&&(this._stream||m._stream).write(e(this.name,a,b)),this},/**
 * Checks if the logger can write messages.
 *
 * @returns {boolean}
 */
d.prototype.isEnabled=function(a){if(!m._enabled)return!1;var b=this._enabled,c=this._level?this._level<=a:m._level<=a,d=!h||h===this;return b&&c&&d},/**
 * Method to enable the logger intance. If loggers have been disabled
 * globally then this flag will not have an immediate effect, until
 * loggers are globally enabled.
 */
d.prototype.enable=function(){return this._enabled=!0,this},/**
 * Method to disable the logger instance. Like {@link Logger#enable},
 * this setting does not have an immediate effect if loggers are globally
 * disabled.
 */
d.prototype.disable=function(){return this._enabled=!1,this},/**
 * Method to make sure *only* this logger logs messages. If another logger
 * is set to only, then the request is silently ignored.
 */
d.prototype.only=function(){return h||(h=this),this},/**
 * Method to remove the logger from the `only` state to allow other loggers
 * set themselves as only.
 */
d.prototype.all=function(){return h=null,this},/**
 * Enables loggers globally.
 */
d.prototype.enableAll=function(){return m.enable()},/**
 * Disables loggers globally.
 */
d.prototype.disableAll=function(){return m.disable()},/**
 * Sets the logging level
 */
d.prototype.level=function(a){return this._level=a,this};/**
 * Default logger instance available
 */
var m=new d("global",{stream:i,level:j.info,enabled:!0});b.exports=d.prototype["default"]=m},{"./consoleStream":17,"./levels":19}],19:[function(a,b,c){b.exports={log:1,info:1,warn:2,error:3}},{}],20:[function(a,b,c){/**
 * Provides functioanlity for aggregating matching rules that can
 * then be compared against a criteria to determine if the criteria
 * is met. The matching rules can be customized beyond simple string
 * comparison. Please take a look at {@link matchers}
 *
 * @class
 *
 * @param {Object} [options={}] - Settings for the rule to be created
 */
function d(a){a=a||{},this._name=d.configureName(a.name),this._match=d.configureMatch(a.match)}var e=a("./matcher"),f=0;/**
 * Helper method to generate rule names.
 *
 * @returns {string} Name of the rule
 */
d.configureName=function(a){return a||"rule-"+f++},/**
 * Helper method to generate rules that can be executed to match criteria.
 *
 * @param {*} match - If match is a function, then we just call that function
 *  to do the comparison for us. Provide a function when looking to customize
 *  how criteria are matched to rules. If match is not a function, the rule
 *  matcher is used. The default rule matcher is generally sufficient. But if
 *  it is not, then provide a function.  Furthermore, match can be an array
 *  of matching rules.
 *
 * @returns {Array.<Rule>} array of configured rule matchers.
 */
d.configureMatch=function(a){return a=a||[],a=a instanceof Array?a:[a],a.map(function(a){return a&&a.constructor===Function?a:e(a)})},/**
 * Method that returns the name of the rule
 *
 * @returns {string} Name of the rule
 */
d.prototype.getName=function(){return this._name},d.prototype.getLength=function(){return this._match.length},/**
 * Method to add a match to the list of matching rules
 *
 * @param {*} match - Matching rules to add. Can any type.
 *
 * @returns {Rule} this instance.
 */
d.prototype.addMatcher=function(a){return this._match=this._match.concat(d.configureMatch(a)),this},/**
 * Method to match only *one* rule
 *
 * @param {string} criteria - Input to test against.
 *
 * @returns {boolean} True if any rule is matched, false otherwise
 */
d.prototype.match=d.prototype.matchAny=function(a){var b,c,e=this._match;for(b=0,c=e.length;c>b;b++)if(d.__match(e[b],a))return!0;return!1},/**
 * Method to test againt *all* rules
 *
 * @param {string} criteria - Input to test against
 *
 * @returns {boolean} True is *all* rules match, false otherwise
 */
d.prototype.matchAll=function(a){var b,c,e=this._match;for(b=0,c=e.length;c>b;b++)if(!d.__match(e[b],a))return!1;return!0},/**
 * Function that call the matcher with the criteria.
 *
 * @private
 * @returns {boolean}
 */
d.__match=function(a,b){try{return a(b)}catch(c){}return!1},d.matcher=e,b.exports=d},{"./matcher":21}],21:[function(a,b,c){/**
 * Default matching rule with strict comparison. Or if the match is a regex
 * then the comparison is done by calling the `test` method on the regex.
 *
 * @param {*} match - If the input is a regex, then matches will be done using
 *  the regex itself. Otherwise, the comparison is done with strict comparison.
 *
 * @returns {boolean}
 */
function d(a){return a instanceof RegExp?function(b){return a.test(b)}:function(b){return b===a}}/**
 * Matcher for file extensions.
 *
 * @param {string} match - extensions to match. You can provide a pipe delimeted
 *  string to specify multiple extensions.  E.g. "js|jsx" will match js and jsx
 *  file extensions.
 *
 * @returns {function} Predicate that takes the criteria to match and returns
 *  true or false.
 */
d.extension=function(a){if(""===a||"string"!=typeof a)throw new TypeError("Matching rule must be a string");return a=new RegExp("\\.("+a+")$"),function(b){return a.test(b)}},/**
 * Matcher for strings. Use this to do strict comparison on strings.
 *
 * @param {string} match - String to match a criteria against.
 *
 * @returns {function} Predicate that takes the criteria to match and returns
 *  true or false.
 */
d.string=function(a){if("string"!=typeof a)throw new TypeError("Match type must be a string");return function(b){return a===b}},/**
 * Matcher for regex. Use this to create regex that can be used for matching
 * criteria.
 *
 * @param {string|RegExp} match - The input can be a string, which is converted
 *  to a regex. The input can also be a regex. This matcher will make sure we
 *  are working with regex matching rules.
 *
 * @returns {function} Predicate that takes the criteria to match and returns
 *  true or false.
 */
d.regex=function(a){if(""!==a&&"string"==typeof a&&(a=new RegExp(a)),!(a instanceof RegExp))throw new TypeError("Match type must be a string or a regex");return function(b){return a.test(b)}},b.exports=d},{}],22:[function(a,b,c){function d(a){return this instanceof d?void(this._transforms=a||[]):new d(a)}d.create=function(a){return new d(a)},d.prototype.use=function(a){return this._transforms.push(a),this},d.prototype.runAsync=function(a){return d.runAsync(a,this._transforms)},d.prototype.runSync=function(a){return d.runSync(a,this._transforms)},d.runAsync=function(a,b){return d.createRunnables(b).reduce(function(a,b){return a.then(b)},Promise.resolve(a))},d.runSync=function(a,b){return d.createRunnables(b).reduce(function(a,b){return b(a)},a)},d.createRunnables=function(a){function b(){c=!0}var c=!1;return a.map(function(a){return function(d){return c?d:a(d,b)}})},b.exports=d},{}],23:[function(a,b,c){/**
 * Facade for System module loader and some extras. This provisions you with functionality
 * for loading modules and process them via plugins. Some relevant information is
 * found [here](https://whatwg.github.io/loader/), but semantics are not quite the same.
 * whatwg/loader was more of a model to stay somewhat on track with the spec's affordances.
 *
 * References:
 * https://whatwg.github.io/loader/#sec-properties-of-the-loader-prototype-object
 *
 * @class
 */
function d(a){a=h.merge({},a),this.settings=a,this.excludes=[],this.ignores=[],this.providers={},this.services={resolve:new j(this),fetch:new k(this),transform:new l(this),dependency:new m(this),precompile:new n(this),compile:new o(this),link:new i(this)},this.controllers={fetcher:new p(this),loader:new r(this),importer:new q(this),registry:new s(this),builder:new t(this)},this.plugins=new v(this,this.services),this.merge(a)}var e=a("loggero").disable(),f=a("dis-isa"),g=a("roolio"),h=a("belty"),i=a("./services/link"),j=a("./services/resolve"),k=a("./services/fetch"),l=a("./services/transform"),m=a("./services/dependency"),n=a("./services/precompile"),o=a("./services/compile"),p=a("./controllers/fetcher"),q=a("./controllers/importer"),r=a("./controllers/loader"),s=a("./controllers/registry"),t=a("./controllers/builder"),u=a("./module"),v=a("./plugin/registrar");/**
 * Method the configures a new instance of bit-loader using the settings
 * from the instance calling this method.
 */
d.prototype.configure=d.prototype.config=function(a){
//
// TODO: Clone services.
//
var b=(new d).merge(h.pick(this,["ignores","excludes"])).merge(this.providers).merge({plugins:this.plugins.serialize()}).merge(a);return b},d.prototype.merge=function(a){if(!a)return this;
// Register any default user provided providers that the services use.
// These guys run after plugins run.
var b=h.pick(a,Object.keys(this.services));for(var c in b)this.services[c].provider(b[c]),this.providers[c]=b[c];
// Register plugins
if(a.plugins){var d=f.isArray(a.plugins)?a.plugins:[a.plugins];d.forEach(function(a){this.plugin(a)}.bind(this))}return a.excludes&&this.exclude(a.excludes),(a.ignores||a.ignore)&&this.ignore(a.ignores||a.ignore),this},/**
 * Method that loads source from storage and pushes the loader source
 * through the processing pipelines of the fetch stage
 *
 * @param {string|Array.<string>} names - Names of modules to import.
 * @param {{path: string, name: string}} referrer - Module requesting
 *  the module. Essential for processing relative paths.
 *
 * @returns {Promise} That when resolved, all loaded module sources are returned
 */
d.prototype.fetch=function(a,b){return this.controllers.fetcher.fetch(a,b)},/**
 * Method that only loads source from storage.  It does not push the loaded
 * source through the processing pipelines.
 *
 * @param {string|Array.<string>} names - Names of modules to import.
 * @param {{path: string, name: string}} referrer - Module requesting
 *  the module. Essential for processing relative paths.
 *
 * @returns {Promise} That when resolved, the loaded module meta objects
 *  are returned.
 */
d.prototype.fetchOnly=function(a,b){return this.controllers.fetcher.fetchOnly(a,b)},/**
 * Method for asynchronously loading modules. This method returns the module(s)
 * exports.
 *
 * @param {string|Array.<string>} names - Names of modules to import.
 * @param {{path: string, name: string}} referrer - Module requesting
 *  the module. Essential for processing relative paths.
 *
 * @returns {Promise} That when resolved, all the imported modules' exports
 *  are returned.
 */
d.prototype["import"]=function(a,b){return this.controllers.importer["import"](a,b)},/**
 * Method that converts a module name to a module file path which can be used
 * for loading a module from disk.
 *
 * @param {string} name - Name of the module to resolve.
 * @param {{path: string, name: string}} referrer - Module requesting
 *  the module. Essential for processing relative paths.
 *
 * @returns {Promise} When resolved it returns a module meta object with
 *  the file path for the module.
 */
d.prototype.resolve=function(a,b){return this.services.resolver.resolve(new u.Meta(a),b).then(function(a){return a.path})},/**
 * Method for asynchronously loading modules. This method returns the module
 * instance(s).
 *
 * @param {string|Array.<string>} names - Names of modules to load.
 * @param {{path: string, name: string}} referrer - Module requesting
 *  the module. Essential for processing relative paths.
 *
 * @returns {Pormise} When resolved it returns the full instance of the
 *  module(s) loaded.
 */
d.prototype.load=function(a,b){return this.controllers.loader.load(a,b)},/*
 * Method to define a module to be asynchronously loaded via the
 * [import]{@link Bitloader#import} method
 *
 * @param {string} name - Name of the module to register.
 * @param {Array.<string>} deps - Collection of dependencies to be loaded and
 *  passed into the factory callback method.
 * @param {Function} factory - Function to be called in order to instantiate
 *  (realize) the module.
 */
//Bitloader.prototype.define = function(/*name, deps, factory, referrer*/) {};
/**
 * Method to register module exports
 *
 * @param {string} name - Name of the module to register exports for.
 * @param {any} exports - Module exports.
 *
 * @returns {Bitloader}
 */
d.prototype.register=function(a,b){return this.controllers.registry.register(a,b),this},/**
 * Method that determines if a module name is excluded from loading and processing.
 *
 * @param {string} name - Name of the module to test for exclusion.
 *
 * @returns {boolean}
 */
d.prototype.isExcluded=function(a){return-1!==this.excludes.indexOf(a)},/**
 * Method to get the source of modules.
 *
 * @param {string|Array.<string>} names - Names of modules to load.
 * @param {{path: string, name: string}} referrer - Module requesting
 *  the source. Essential for processing relative paths.
 *
 * @returns {Promise} When resolved it returns the source(s)
 */
d.prototype.getSource=function(a,b){var c=this;return this.controllers.fetcher.fetch(a,b).then(function(b){return f.isString(a)?c.getModule(b.id).source:b.map(function(a){return c.getModule(a.id).source})})},/**
 * Helper method to push source string through the transformation pipeline
 *
 * @param {string} source - Source code to transform.
 *
 * @returns {Promise} When resolved it returns the transformed source code.
 */
d.prototype.transform=function(a){return this.services.transform.runAsync(new u.Meta({name:"@transform",source:a})).then(function(a){return a.source})},/**
 * Clears the registry, which means that all cached modules and other pertinent
 * data will be deleted.
 *
 * @returns {Bitloader}
 */
d.prototype.clear=function(){return this.controllers.registry.clear(),this},/**
 * Checks if the module instance is in the module registry
 *
 * @param {string} id - Id of the module to check if it's cached
 *
 * @returns {boolean}
 */
d.prototype.hasModule=function(a){return this.controllers.registry.hasModule(a)},/**
 * Returns the module instance if one exists.  If the module instance isn't in the
 * module registry, then a TypeError exception is thrown
 *
 * @param {string} id - Id of the module to get from cache
 *
 * @return {Module} Module instance from cache
 */
d.prototype.getModule=function(a){return this.controllers.registry.getModule(a)},/**
 * Finds all modules that match the criteria provided.
 *
 * @param {object | string} criteria - Pattern (shape) or ID for matching the modules to be returned
 *
 * @return {Array.<Module>} Array of modules that match the criteria
 */
d.prototype.findModules=function(a){return this.controllers.registry.findModules(a)},/**
 * Finds and returns the first module to match the criteria provided.
 *
 * @param {object | string} criteria - Pattern (shape) or ID for matching the modules to be returned
 *
 * @return {Module} First module that matches the criteria
 */
d.prototype.findModule=function(a){return this.controllers.registry.findModule(a)},/**
 * Method to delete a module from the registry.
 *
 * @param {string} id - Id of the module to delete
 *
 * @returns {Module} Deleted module
 */
d.prototype.deleteModule=function(a){if(!(a instanceof u||a instanceof u.Meta))throw new TypeError("Input is not an instance of Module");if(!this.controllers.registry.hasModule(a.id))throw new TypeError("Module instance `"+a.name+"` does not exists");return this.controllers.registry.deleteModule(a.id)},/**
 * Method to add module names to exclude. Modules in this list will
 * basically add modules with source of empty string. Generally used
 * to exclude external dependencies where module names are not paths
 * that require name resolution. e.g. jquery, react, path...
 *
 * @param {string|Array.<string>} name - Module name (or list of names)
 *  to exclude from loading and processing. This will add a module entry
 *  with the source  of empty string and the ID is the same as the name.
 *
 * @returns {Bitloader}
 */
d.prototype.exclude=function(a){return f.isArray(a)?this.excludes=this.excludes.concat(a):this.excludes.push(a),this},/**
 * Add ignore rules for configuring what the different pipelines shoud not process.
 *
 * @param {Object} rule - Rule configuration
 *
 * @returns {Bitloader}
 */
d.prototype.ignore=function(a){function b(a){return f.isPlainObject(a)||(a={name:a}),a}function c(a){return a.services?"*"===a.services?a.services=g:a.services=f.isArray(a.services)?a.services:[a.services]:a.services=["transform","dependency"],a}function d(a){var b,c,d=a.services;for(var f in h.omit(a,["services"]))for(b=0,c=d.length;c>b;b++)e[d[b]].ignore(f,a[f])}if(!a)throw new TypeError("Must provide a rule configuration");f.isArray(a)||(a=[a]);var e=this.services,g=Object.keys(this.services);return a.map(b).map(c).forEach(d),this.ignores=this.ignores.concat(a),this},/**
 * Registers plugins into the pipeline.
 *
 * @param {object} settings - Object whose keys are the name of the particular
 *  pipeline they intend to register with. For example, if the plugin is to
 *  register a `transform` and a `dependency` pipeline handler, then the
 *  plugin object will have entries with those names. E.g.
 *
 * @returns {Bitloader}
 *
 *  @example
 *  bitloader.plugin("js", {
 *    "transform": function(meta) {
 *      console.log(meta);
 *    },
 *    "dependency": function(meta) {
 *      console.log(meta);
 *    }
 *  });
 */
d.prototype.plugin=function(a,b){return f.isPlainObject(a)&&(b=a,a=b.name),this.plugins.configureManager(a,b),this},
// Expose constructors and utilities
d.Module=u,d.Rule=g,d.logger=e,b.exports=d},{"./controllers/builder":26,"./controllers/fetcher":27,"./controllers/importer":29,"./controllers/loader":30,"./controllers/registry":31,"./module":34,"./plugin/registrar":38,"./services/compile":41,"./services/dependency":42,"./services/fetch":44,"./services/link":45,"./services/precompile":46,"./services/resolve":47,"./services/transform":48,belty:9,"dis-isa":53,loggero:18,roolio:20}],24:[function(a,b,c){function d(a){function b(){f(this,a)}return b.prototype=Object.create(e.prototype),b.prototype.constructor=b,b}function e(){}function f(a,b){return o.isBuffer(b)?Object.freeze(b):b&&b.constructor===Object?Object.freeze(g(a,b)):o.isArray(b)?Object.freeze(h(a,b)):b}function g(a,b){var c=Object.keys(b).reduce(function(a,c){return a[c]={get:i(b[c]),set:j(c),enumerable:!0},a},{});return Object.defineProperties(a,c),a}function h(a,b){return b.map(function(a){return f(a,a)})}function i(a){var b,c;return function(){return b||(c=m(a)?a:f(a,a),b=!0),c}}function j(a){return function(b){throw new Error("Unable to set "+JSON.stringify(a)+" to "+JSON.stringify(b)+". FYI - Immutable structures are readonly.")}}function k(a,b,c){return a&&(b&&b.constructor===Object||o.isArray(b))?l(a,b).reduce(function(d,e){return d[e]=b.hasOwnProperty(e)&&a[e]!==b[e]?k(a[e],c(b[e],e,a),n):a[e],d},o.isArray(a)?a.slice(0):{}):b}function l(a,b){var c=[].concat(Object.keys(a)).concat(Object.keys(b)).reduce(function(a,b){return a[b]=!0,a},{});return Object.keys(c)}function m(a){return a&&(a.constructor===Object||o.isArray(a))?Object.isFrozen(a):!0}function n(a){return a}var o=a("dis-isa");e.prototype.merge=function(a,b){if(null===a||void 0===a||this===a)return this;var c=k(this,a,b||n);return c===this?this:f(Object.create(Object.getPrototypeOf(this)),c)},d.buildImmutable=f,d.buildUpdateTree=k,d.BaseImmutable=e,b.exports=d},{"dis-isa":53}],25:[function(a,b,c){function d(a){if(!a)throw new Error("Controller contructor requires a context");this.context=a}b.exports=d},{}],26:[function(a,b,c){function d(a){n.call(this,a),this.pipeline=new o([g(a),h(a)])}function e(a,b){return b.getDependencyExportsByName||(b=b.configure({getDependencyExportsByName:f(a,b)})),b=b.configure({source:b.source+i(b)}),a.pipeline.runSync(b)}function f(a,b){return function(c){return b.deps.filter(function(a){return a.name===c}).map(function(b){return a.build(b.id).exports})[0]}}function g(a){return k.serviceRunnerSync(a,m.State.LOADED,m.State.COMPILE,a.services.compile)}function h(a){return k.serviceRunnerSync(a,m.State.COMPILE,m.State.READY,a.services.link)}/**
 * Builds a `# sourceURL` string from the URL.
 *
 * @private
 *
 * @param {Module.Meta} moduleMeta - Module meta object this function is processing
 * @returns {string} The proper source url to be inserted in the module source
 */
function i(a){return!a.path||j(a)?"":"\n//# sourceURL="+a.path.replace(/^(https?):\/\/\/?[^\/]*/,"")}/**
 * Verifies if the module already has a `sourceURL` so that we don't override it.
 * @private
 *
 * @param {Module.Meta} moduleMeta - Module meta object this function is processing
 * @returns {boolean}
 */
function j(a){return a.source&&-1!==a.source.indexOf("//# sourceURL=")}
//var logger   = require("loggero").create("controllers/builder");
var k=a("./helpers"),l=a("../inherit"),m=a("../module"),n=a("../controller"),o=a("then-pipeline");l.base(d)["extends"](n),d.prototype.build=function(a){return this.context.controllers.registry.getModuleState(a)===m.State.READY?this.context.controllers.registry.getModule(a):e(this,this.context.controllers.registry.getModule(a))},b.exports=d},{"../controller":25,"../inherit":32,"../module":34,"./helpers":28,"then-pipeline":22}],27:[function(a,b,c){function d(a){s.call(this,a),this.inProgress={},this.pipeline=new t([h(a),i(a),j(a),l(this),k(a)])}function e(a){return function(b){return n.info("fetch",b.name,b.referrer),a.inProgress.hasOwnProperty(b.id)?a.inProgress[b.id].then(function(){return b}):a.context.controllers.registry.hasModule(b.id)&&a.context.controllers.registry.getModuleState(b.id)<r.State.LOADED?m(a,b).then(function(){return b}):Promise.resolve(b)}}function f(a){return a=a||{},function(b){return new r.Meta({name:b,referrer:{name:a.name,path:a.path,id:a.id}})}}function g(a){var b=a.context;return function(c){return b.isExcluded(c.name)?(c=c.configure({id:c.name,path:null,source:""}),b.controllers.registry.setModule(c,r.State.LOADED),Promise.resolve(c)):b.services.resolve.runAsync(c).then(function(b){return a.context.controllers.registry.hasModule(b.id)||a.context.controllers.registry.setModule(b,r.State.RESOLVE),b})}}function h(a){return q.serviceRunner(a,r.State.RESOLVE,r.State.FETCH,a.services.fetch)}function i(a){return q.serviceRunner(a,r.State.FETCH,r.State.TRANSFORM,a.services.transform)}function j(a){return q.serviceRunner(a,r.State.TRANSFORM,r.State.DEPENDENCY,a.services.dependency)}function k(a){return q.serviceRunner(a,r.State.DEPENDENCY,r.State.LOADED,a.services.precompile)}function l(a){return function(b){return a.fetch(b.deps,b).then(function(a){return b.configure({deps:a})})}}function m(a,b){function c(){delete a.inProgress[b.id]}var d=a.pipeline.runAsync(b);return a.inProgress[b.id]=d,d.then(c,c),d}var n=a("loggero").create("controllers/fetcher"),o=a("dis-isa"),p=a("../inherit"),q=a("./helpers"),r=a("../module"),s=a("../controller"),t=a("then-pipeline");p.base(d)["extends"](s),d.prototype.fetch=function(a,b){return this._fetch(a,b,e(this))},d.prototype.fetchOnly=function(a,b){return this._fetch(a,b,h(this.context))},d.prototype._fetch=function(a,b,c){return o.isArray(a)?Promise.all(a.map(f(b)).map(g(this)).map(function(a){return a.then(c)})):g(this)(f(b)(a)).then(c)},b.exports=d},{"../controller":25,"../inherit":32,"../module":34,"./helpers":28,"dis-isa":53,loggero:18,"then-pipeline":22}],28:[function(a,b,c){function d(a,b,c){return a.controllers.registry.hasModule(b)&&a.controllers.registry.getModuleState(b)===c}function e(a,b){return function(c){return a.controllers.registry.hasModule(c.id)&&a.controllers.registry.setModule(c,b),c}}function f(a,b,c,f,g){return g&&d(a,g.id,b)?f.runAsync(e(a,c)(g)):Promise.resolve(g)}function g(a,b,c,f,g){return g&&d(a,g.id,b)?f.runSync(e(a,c)(g)):g}function h(a,b,c,d){return function(e){return f(a,b,c,d,e)}}function i(a,b,c,d){return function(e){return g(a,b,c,d,e)}}b.exports={ensureRegisteredState:d,serviceRunner:h,serviceRunnerSync:i,runService:f,runServiceSync:g,setState:e}},{}],29:[function(a,b,c){/**
 * Module importer. Primary function is to load Module instances and resolving
 * their dependencies in order to make the Module fully consumable.
 */
function d(a){j.call(this,a)}function e(a,b){return function(c){return a._getModule(c,b)}}var f=a("loggero").create("controllers/importer"),g=a("dis-isa"),h=a("../inherit"),i=a("../module"),j=a("../controller");h.base(d)["extends"](j),/**
 * Import is the method to load a Module
 *
 * @param {Array<string> | string} names - module(s) to import
 *
 * @returns {Promise}
 */
d.prototype["import"]=function(a,b){return f.info("import",a,b),g.isArray(a)?Promise.all(a.map(e(this,b))):e(this,b)(a)},/**
 * Gets the module by name.  If the module has not been loaded before, then
 * it is loaded via the module loader
 *
 * @param {Array<string>} names - Array of module names
 * @param {Object} options
 */
d.prototype._getModule=function(a,b){b=b||{};var c=this.context,d=c.controllers.registry;return d.hasModule(a)&&d.getModuleState(a)===i.State.READY?Promise.resolve(d.getModule(a).exports):new Promise(function(b,d){function e(a){f.error(a),d(a)}function g(a){b(c.controllers.registry.getModule(a.id).exports)}c.controllers.loader.load(a).then(g,e)})},b.exports=d},{"../controller":25,"../inherit":32,"../module":34,"dis-isa":53,loggero:18}],30:[function(a,b,c){/**
 * The purpose of Loader is to return full instances of Module. Overview of the workflow:
 *
 * 1. Resolve - converts name to path for loading the module from storage.
 * 2. Fetch - load source from storage (remote server, local file system).
 * 3. Transform - transpile the source that was fetched.
 * 4. Dependency - parses out dependencies on other modules.
 * 5. Compile - evaluates the source that was fetched and transformed.
 * 6. Link - processes the entire dependency graph in order to instantiate modules.
 */
function d(a){j.call(this,a)}function e(a,b){return function(c){return c?f(a,c,b).then(g(a)):Promise.reject("Must provide the name of the module to load")}}function f(a,b,c){return a.context.controllers.fetcher.fetch(b,c)}function g(a){return function(b){return a.context.controllers.builder.build(b.id)}}
//var logger = require("loggero").create("controllers/loader");
var h=a("dis-isa"),i=a("../inherit"),j=a("../controller");i.base(d)["extends"](j),/**
 * Handles the process of returning the instance of the Module if one exists, otherwise
 * the workflow for creating the instance is kicked off, which will eventually lead to
 * the creation of a Module instance
 *
 * @param {string} name - The name of the module to load.
 * @param {{path: string, name: string}} referrer - Object with the
 *  location and name of the requesting module.
 *
 * @returns {Promise} - Promise that will resolve to a Module instance
 */
d.prototype.load=function(a,b){return h.isString(a)?e(this,b)(a):Promise.all(a.map(e(this,b)))},b.exports=d},{"../controller":25,"../inherit":32,"dis-isa":53}],31:[function(a,b,c){
//
// TODO: Make the registry stateless.
// I prefer controllers being stateless. But keeping the instance of the repository will do for now.
//
function d(a){h.call(this,a),this.repository=new g}
//var logger = require("loggero").create("controllers/registry");
var e=a("../inherit"),f=a("../module"),g=a("../repository"),h=a("../controller");e.base(d)["extends"](h),d.prototype.register=function(a,b){return this.setModule(new f.Meta({id:a,name:a,exports:b}),f.State.READY)},d.prototype.hasModule=function(a){return this.repository.hasItem(a)},d.prototype.findModules=function(a){return this.repository.findAll({module:a}).map(function(a){return a.module})},d.prototype.findModule=function(a){var b=this.repository.findFirst({module:a});return b?b.module:null},d.prototype.getModule=function(a){if(!this.hasModule(a))throw new Error("Module with id `"+a+"` not found");return this.repository.getItem(a).module},d.prototype.setModule=function(a,b){var c=a.id;if(this.hasModule(c)&&this.getModuleState(c)===b)throw new Error("Module instance `"+a.name||a.id+"` already exists");return this.repository.setItem(c,{module:a,state:b}),a},d.prototype.deleteModule=function(a){if(!this.hasModule(a))throw new Error("Unable to delete module with id `"+a+"`. Module not found.");return this.repository.deleteItem(a).module},d.prototype.getModuleState=function(a){if(!this.hasModule(a))throw new Error("Module instance `"+a+"` not found");return this.repository.getItem(a).state},b.exports=d},{"../controller":25,"../inherit":32,"../module":34,"../repository":39}],32:[function(a,b,c){function d(a){this.Base=a}function e(a){return e.base(a)}d.prototype["extends"]=function(a){return a=a&&a.prototype?a.prototype:a,this.Base.prototype=Object.create(a),this.Base.prototype.constructor=this.Base,this},d.prototype.mixin=function(a){return a=a&&a.prototype?a.prototype:a,Object.assign(this.Base.prototype,a),this.Base.prototype.constructor=this.Base,this},e.base=function(a){return new d(a)},b.exports=e},{}],33:[function(a,b,c){function d(a){return j.call(this),this.merge(d.configure({},a))}var e=a("dis-isa"),f=a("roolio"),g=a("belty"),h=a("./blueprint"),i=a("./inherit"),j=h({matches:null,ignores:null});i.base(d)["extends"](j),d.prototype.configure=function(a){return this.merge(d.configure(this,a))},/**
 * Method for adding matching rules used for determining whether or
 * not data should be processed by the handler.
 *
 * @prop {string} - Name of the property to test for matches.
 * @matches {array<string>|srting} - Matching rule pattern
 *
 * @returns {Plugin}
 */
d.prototype.match=function(a,b){var c={};return c[a]=b,this.merge({matches:d.mergeMatcher(this.matches,c)})},/**
 * Add ignore rules to prevent certain data from being processed
 * by the handler.
 */
d.prototype.ignore=function(a,b){var c={};return c[a]=b,this.merge({ignores:d.mergeMatcher(this.ignores,c)})},d.prototype.runMatch=function(a){return!!d.runMatchers(this.matches,a)},d.prototype.runIgnore=function(a){return!(!this.ignores||!d.runMatchers(this.ignores,a))},d.prototype.canExecute=function(a){return this.runIgnore(a)?!1:this.runMatch(a)},d.prototype.serialize=function(){return g.merge({},{ignores:this.ignores,matches:this.matches})},d.configure=function(a,b){b=b||{};var c=d.mergeExtensions(a.matches,b.extensions);return{matches:d.mergeMatcher(c,b.matches||b.match),ignores:d.mergeMatcher(a.ignores,b.ignores||b.ignore)}},/**
 * Method to merge extensions into the container of pattern matching
 * rules.
 */
d.mergeExtensions=function(a,b){return b?(e.isArray(b)&&(b=b.join("|")),d.mergeMatcher(a,{path:new RegExp("[\\w]+\\.("+b+")$","mi")})):a},/**
 * Method that merges matches into an object. This also concatinates
 * all the matcher arrays. Matchers are object with properties for
 * pattern matching against input objects.
 */
d.mergeMatcher=function(a,b){return b?Object.keys(b).reduce(function(a,c){return a[c]||(a[c]=[]),e.isArray(b[c])?b[c]=a[c].concat(b[c]):a[c].push(b[c]),a},g.merge({},a)):a},d.buildMatchers=function(a){return Object.keys(a).reduce(function(b,c){return b[c]||(b[c]=new f),b[c]=b[c].addMatcher(a[c]),b},{})},/**
 * Checks if the handler can process the input data based on whether
 * or not there are matches to be processed and if any of the matches
 * do match.
 */
d.runMatchers=function(a,b){if(!a)return!0;var c=d.buildMatchers(a);return Object.keys(c).some(function(a){return c[a].match(b[a])})},b.exports=d},{"./blueprint":24,"./inherit":32,belty:9,"dis-isa":53,roolio:20}],34:[function(a,b,c){/**
 * Module class definition. This contains all information used in the processed
 * of creating the module as well as the data the host application consumes. Perhaps
 * the single most important piece of information is `exports`, which is ultimately
 * the piece of data that the host application consumes.
 *
 * @class
 *
 * @property {string} id - Module id
 * @property {string} name - Module name
 * @property {string[]} deps - Array of module dependencies
 * @property {function} factory - Function that generates the data a particular module exports
 * @property {any} exports - Data exported by a module
 */
function d(a){if(!a)throw new TypeError("Must provide options to create the module");a.hasOwnProperty("exports")&&(this.exports=a.exports),a.hasOwnProperty("factory")&&(this.factory=a.factory),this.type=a.type||k.UNKNOWN,this.id=a.id||a.name,this.name=a.name,this.deps=a.deps?a.deps.slice(0):[]}/**
 * Module meta class definition. This is an intermediary representation of the processed
 * module information before a proper Module instance is created. This is what all pipelines
 * interact with before the build stage creates a Module instance.
 *
 * @class
 * @memberof Module
 */
function e(a){if(a=a||{},j.isString(a)&&(a={name:a}),!j.isString(a.name))throw new TypeError("Must provide a name, which is used by the resolver to resolve the path for the resource");this.deps=[],f(this,a)}/**
 * Merges in options into a module meta object
 *
 * @ignore
 */
function f(a,b){b=b||{};var c=i.extend(a,b);return b.deps&&(c.deps=b.deps.slice(0)),b.path&&(c.directory=g(b.path),c.fileName=h(b.path)),c}function g(a){return(a||"").replace(/([^\/\\]+)$/gim,"")}function h(a){var b=/[^\/\\]+$/gim.exec(a||"");return b?b[0]:""}var i=a("belty"),j=a("dis-isa"),k={UNKNOWN:"UNKNOWN",AMD:"AMD",//Asynchronous Module Definition
CJS:"CJS",//CommonJS
IIFE:"IIFE"},l={REGISTERED:0,RESOLVE:1,FETCH:2,TRANSFORM:3,DEPENDENCY:4,LOADED:5,COMPILE:6,LINK:7,READY:8};/**
 * Returns the directory part of a file path.
 */
e.prototype.getDirectory=function(){return this.directory||""},/**
 * Returns the file name of the file path.
 */
e.prototype.getFileName=function(){return this.fileName||""},/**
 * Returns the file path, which is the full path for the file in storage.
 */
e.prototype.getFilePath=function(){return this.path||""},/**
 * Safely merges data into the instance of module meta. This returns a new instance
 * to keep the module meta object as immutable as possible.
 *
 * @param {object} options - Options to merge into the module meta instance.
 *
 * @returns {Meta} New module meta instance with the aggregated options merged in.
 */
e.prototype.configure=function(a){
// Provide immutability to prevent side effects
return f(new e(this),a)},/**
 * Verifies that a module meta object is either already compiled or can be compiled.
 *
 * @param {Meta} moduleMeta - Module meta instance.
 *
 * @returns {boolean}
 */
e.validate=function(a){if(!a)throw new TypeError("Must provide options");if(!e.isCompiled(a)&&!e.canCompile(a))throw new TypeError("ModuleMeta must provide a `source` string or `exports`.")},/**
 * Verifies if a module meta object has dependencies.
 *
 * @param {Meta} moduleMeta - Module meta instance.
 *
 * @returns {boolean}
 */
e.hasDependencies=function(a){return a.deps.length},/**
 * A module meta object is considered compiled if it has a `exports` or `factory` method.
 * That's because those are the two things that the compile step actually generates
 * before creating a Module instance.
 *
 * @param {Meta} moduleMeta - Module meta instance.
 *
 * @returns {boolean}
 */
e.isCompiled=function(a){return a.hasOwnProperty("exports")||j.isFunction(a.factory)},/**
 * Checks if the module meta object can be compiled by verifying that it has NOT
 * already been compiled and that it has a `source` property that need to be compiled.
 *
 * @param {Meta} moduleMeta - Module meta instance.
 *
 * @returns {boolean}
 */
e.canCompile=function(a){return!e.isCompiled(a)&&j.isString(a.source)},d.Meta=e,d.Type=k,d.State=l,b.exports=d},{belty:9,"dis-isa":53}],35:[function(a,b,c){/**
 * Plugin Handler. This is an abstraction for functions that are executed by
 * plugins. It provides a way to also encapsulate information about dynamic
 * handlers that need to be loaded during runtime.
 */
function d(a){return j.call(this),a=a||{},this.merge(f.pick(a,["id","context"])).configure(a)}var e=a("dis-isa"),f=a("belty"),g=a("../inherit"),h=a("../matches"),i=a("../blueprint"),j=i({context:null,handler:null,options:null,id:null,matchers:new h});g.base(d)["extends"](j),d.prototype.isDynamic=function(){return e.isString(this.handler)},/**
 * Configures handler with the provided options.
 */
d.prototype.configure=function(a){return(e.isFunction(a)||e.isString(a))&&(a={handler:a}),this.merge(f.pick(a,["handler","options"])).merge({matchers:this.matchers.configure(a.matchers||a)})},d.prototype.canExecute=function(a){return this.matchers.canExecute(a)},d.prototype.run=function(a,b){return this.canExecute(a)?Promise.resolve(this.handler(a,this,b)):Promise.resolve(a)},d.prototype.serialize=function(){return f.merge({matchers:this.matchers.serialize()},f.pick(this,["handler","id","options"]))},b.exports=d},{"../blueprint":24,"../inherit":32,"../matches":33,belty:9,"dis-isa":53}],36:[function(a,b,c){/**
 * Plugin Manager is a plugin container that facilitates the execution of
 * plugins.
 */
function d(a){return n.call(this),a=a||{},this.merge({id:a.id||i(),context:a.context}).configure(a)}function e(a,b){return function(c){var d=b[c].id||a.getPluginIdFor(c);return a.context.configurePlugin(d,b[c]),{serviceName:c,plugin:a.context.getPlugin(d)}}}function f(a){return function(b){return a.plugins[b.plugin.id]!==!0}}function g(a){return function(b){return a.context.registerPluginWithService(b.serviceName,h(a,b.plugin.id)),b}}function h(a,b){var c=a.id,d=a.context;return function(a){return d.getManager(c).canExecute(a)?d.getPlugin(b).run(a):a}}function i(){return"manager-"+o++}var j=a("belty"),k=a("../inherit"),l=a("../matches"),m=a("../blueprint"),n=m({id:null,context:null,plugins:{},matchers:new l});k.base(d)["extends"](n),/**
 * Configure plugin. This is a way to setup matching rules and handlers
 * in a single convenient call.
 *
 * @returns {Plugin}
 */
d.prototype.configure=function(a){var b=Object.keys(j.omit(a,["matchers","matches","match","ignores","ignore","extensions","id","context","name"])),c=b.map(e(this,a)).filter(f(this)).map(g(this)).reduce(function(a,b){return a[b.plugin.id]=!0,a},{});return this.merge({plugins:c,matchers:this.matchers.configure(a.matchers||a)})},d.prototype.getPluginIdFor=function(a){return this.id+"-plugin-"+a},d.prototype.canExecute=function(a){return this.matchers.canExecute(a)},d.prototype.serialize=function(){var a=this;return j.merge({plugins:Object.keys(this.plugins).map(function(b){return a.context.getPlugin(b).serialize()})},j.pick(this,["id"]))};var o=0;d.pluginRunner=h,b.exports=d},{"../blueprint":24,"../inherit":32,"../matches":33,belty:9}],37:[function(a,b,c){function d(a){return n.call(this),this.merge(j.pick(a,["id","context"]))}function e(a){return function(b){return a.context.getHandler(b)}}function f(a){return function(b){(k.isFunction(b)||k.isString(b))&&(b={handler:b});var c=b.id||a.getHandlerId();return a.context.hasHandler(c)||a.context.configureHandler(c,b),a.context.getHandler(c)}}function g(a){return function(b){return b.canExecute(a)}}/**
 * Method that return a function that executes a plugin handler.
 */
function h(a,b){return function(c){return c?Promise.resolve(a).then(function(a){return a.run(c,b)}).then(function(a){return c.configure(a)}):Promise.resolve()}}/**
 * Load dynamic handlers if there are any that need to be loaded for
 * the current plugin
 */
function i(a){return a.context.loadHandlers()}
//var logger = require("loggero").create("plugin");
var j=a("belty"),k=a("dis-isa"),l=a("../inherit"),m=a("../blueprint"),n=m({context:null,handlers:{},id:null});l.base(d)["extends"](n),d.prototype.configure=function(a){k.isArray(a)||(a=[a]);var b=a.filter(Boolean).map(f(this)).reduce(function(a,b){return a[b.id]=!0,a},{});return this.merge({handlers:b})},/**
 * Runs all plugin handlers to process the data.
 */
d.prototype.run=function(a){function b(){j=!0}function c(a){return j?void 0:a}var d=this,f=this.handlers,j=!1;return i(d).then(function(){return Object.keys(f).map(e(d)).filter(g(a)).reduce(function(a,d){return a.then(c).then(h(d,b))},Promise.resolve(a))})},d.prototype.serialize=function(){var a=this;return j.merge({handlers:Object.keys(this.handlers).map(function(b){return a.context.getHandler(b).serialize()})},j.pick(this,["id"]))};var o=1;d.prototype.getHandlerId=function(){return this.id+"-handler-"+o++},b.exports=d},{"../blueprint":24,"../inherit":32,belty:9,"dis-isa":53}],38:[function(a,b,c){/**
 * Registrar is a stateful service for managing registration and loading
 * of plugins.
 */
function d(a,b){this.context=a,this.services=b,this.managers={},this.plugins={},this.handlers={}}function e(a,b){return function(c){b.forEach(function(b,d){a.configureHandler(b.id,{handler:c[d]})})}}var f=a("loggero").create("plugin/registrar"),g=a("./manager"),h=a("./plugin"),i=a("./handler"),j=a("belty"),k=1;d.prototype.configure=function(a){return j.merge(this,j.pick(a,["managers","plugins","handlers"]))},d.prototype.configureManager=function(a,b){a||(a=k++);var c=this.managers[a]||new g({context:this,id:a});return this.managers[a]=c.configure(b),this},d.prototype.hasManager=function(a){return this.managers.hasOwnProperty(a)},d.prototype.getManager=function(a){return this.managers[a]},d.prototype.getManagers=function(a){var b=this;return(a||Object.keys(b.managers)).map(function(a){return b.managers[a]})},d.prototype.configurePlugin=function(a,b){var c=this.plugins[a]||new h({context:this,id:a});return this.plugins[a]=c.configure(b),this},d.prototype.hasPlugin=function(a){return this.plugins.hasOwnProperty(a)},d.prototype.getPlugin=function(a){return this.plugins[a]},d.prototype.getPlugins=function(a){var b=this;return(a||Object.keys(b.plugins)).map(function(a){return b.plugins[a]})},d.prototype.configureHandler=function(a,b){var c=this.handlers[a]||new i({context:this,id:a});return this.handlers[a]=c.configure(b),this},d.prototype.hasHandler=function(a){return this.handlers.hasOwnProperty(a)},d.prototype.getHandler=function(a){return this.handlers[a]},d.prototype.getHandlers=function(a){var b=this;return(a||Object.keys(b.handlers)).map(function(a){return b.handlers[a]})},d.prototype.loadHandlers=function(a){if(this.pending)return Promise.resolve();var b=this,c=b.getHandlers(a),d=Object.keys(c).filter(function(a){return c[a].isDynamic()}).map(function(a){return c[a]});if(d.length){var g=d.map(function(a){return a.handler});return f.log("loading",g),d.forEach(function(a){
// While the plugin is loading, it cannot process anything. So we will
// default any calls to it to pass thru. This is in a separate context
// than application modules, so the only modules that are pass thru
// are module dependencies for the plugin themselves.
b.configureHandler(a.id,{handler:j.noop})}),b.pending=b.context["import"](g).then(e(this,d)).then(function(){f.log("loaded",g),delete b.pending}),b.pending}return Promise.resolve()},d.prototype.registerPluginWithService=function(a,b){if(!this.services)throw TypeError("Unable to register plugin. Services have not been configured");if(!this.services.hasOwnProperty(a))throw TypeError("Unable to register plugin. '"+a+"' service does not exist");return this.services[a].use(b),this},d.prototype.serialize=function(){return this.getManagers().map(function(a){return a.serialize()})},b.exports=d},{"./handler":35,"./manager":36,"./plugin":37,belty:9,loggero:18}],39:[function(a,b,c){/**
 * Generic repository for data.
 */
function d(a){a=a||{},this.items=a.items||{}}function e(a,b){if(a===b)return!0;if(!a||!b)return!1;for(var c in a)if(a.hasOwnProperty(c)&&a[c]!==b[c])return a[c]&&(f.isArray(a[c])||f.isObject(a[c]))?e(a[c],b[c]):!1;return!0}var f=a("dis-isa");d.prototype.clear=function(){return delete this.items,this.items={},this},d.prototype.hasItem=function(a){return this.items.hasOwnProperty(a)},d.prototype.getItem=function(a){if(!this.hasItem(a))throw new Error("`"+a+"` not found");return this.items[a]},d.prototype.deleteItem=function(a){if(!this.hasItem(a))throw new Error("Item with `"+a+"` cannot be deleted. Item not found");var b=this.items[a];return delete this.items[a],b},d.prototype.setItem=function(a,b){return this.items[a]=b},d.prototype.findAll=function(a){if(this.hasItem(a))return[this.getItem(a)];var b=[],c=this.items;for(var d in c)e(a,c[d])&&b.push(c[d]);return b},d.prototype.findFirst=function(a){if(this.hasItem(a))return[this.getItem(a)];var b=this.items;for(var c in b)if(e(a,b[c]))return b[c]},b.exports=d},{"dis-isa":53}],40:[function(a,b,c){function d(a){if(!a)throw new Error("Service constructor requires a context");this.context=a,this.transforms=[],this.matchers=new k}function e(a){return function(b){return l.runAsync(b,a.transforms).then(i(a,b))}}function f(a){return function(b){return j(a,b)?Promise.resolve(a._provider(b)).then(i(a,b)):b}}function g(a){return function(b){return i(a,b)(l.runSync(b,a.transforms))}}function h(a){return function(b){return j(a,b)?i(a,b)(a._provider(b)):b}}function i(a,b){return function(c){return a.processResult(b,c)}}function j(a,b){return a._provider&&a.canProcess(b)}var k=a("./matches"),l=a("then-pipeline");d.prototype.provider=function(a){return this._provider=a,this},d.prototype.use=function(a){return this.transforms.push(a),this},d.prototype.ignore=function(a,b){return this.matchers=this.matchers.ignore(a,b),this},d.prototype.match=function(a,b){return this.matchers=this.matchers.match(a,b),this},d.prototype.canExecute=function(a){return this.matchers.canExecute(a)},d.prototype.canProcess=function(a){return this.canExecute(a)},d.prototype.runAsync=function(a){return this._logger&&this._logger.log(a.name,a),this.canProcess(a)?Promise.resolve(a).then(e(this)).then(f(this)):Promise.resolve(a)},d.prototype.runSync=function(a){return this._logger&&this._logger.log(a.name,a),this.canProcess(a)?[g(this),h(this)].reduce(function(a,b){return b(a)},a):a},d.prototype.processResult=function(a,b){return b&&a!==b?a.configure(b):a},b.exports=d},{"./matches":33,"then-pipeline":22}],41:[function(a,b,c){function d(a){h.call(this,a),this._logger=e}var e=a("loggero").create("service/compile"),f=a("../inherit"),g=a("../module"),h=a("../service"),i=a("./eval");f.base(d)["extends"](h),d.prototype.canProcess=function(a){return this.canExecute(a)&&g.Meta.canCompile(a)},d.prototype.runSync=function(a){if(this._logger&&this._logger.log(a.name,a),!this.canProcess(a))return a;var b={exports:{}};return i(this.context.controllers.loader,b,b.exports,a.getDependencyExportsByName,a.directory,a.path,a.source),a.configure(b)},b.exports=d},{"../inherit":32,"../module":34,"../service":40,"./eval":43,loggero:18}],42:[function(a,b,c){function d(a){h.call(this,a),this._logger=e}var e=a("loggero").create("service/dependency"),f=a("../inherit"),g=a("dis-isa"),h=a("../service");f.base(d)["extends"](h),d.prototype.canProcess=function(a){return this.canExecute(a)&&g.isString(a.source)},b.exports=d},{"../inherit":32,"../service":40,"dis-isa":53,loggero:18}],43:[function(require,module,exports){/*eslint no-unused-vars: 0*/
module.exports=function(loader,module,exports,require,__dirname,__filename){eval(arguments[arguments.length-1])}},{}],44:[function(a,b,c){function d(a){g.call(this,a),this._logger=e}var e=a("loggero").create("service/fetch"),f=a("../inherit"),g=a("../service");f.base(d)["extends"](g),d.prototype.canProcess=function(a){return this.canExecute(a)&&a.hasOwnProperty("path")&&!a.hasOwnProperty("code")&&!a.hasOwnProperty("source")&&!a.hasOwnProperty("factory")},b.exports=d},{"../inherit":32,"../service":40,loggero:18}],45:[function(a,b,c){function d(a){h.call(this,a)}var e=a("loggero").create("service/linker"),f=a("../inherit"),g=a("../module"),h=a("../service");f.base(d)["extends"](h),d.prototype.canProcess=function(a){return this.canExecute(a)&&g.Meta.isCompiled(a)},/**
 * The linker step is where we take the evaluated source, build all the dependencies
 * and call the factory method on the module if available.
 *
 * This is the step where the Module instance is finally created.
 *
 * @returns {Module}
 */
d.prototype.runSync=function(a){function b(a){e.log(a.name,a);
// Build all the dependecies in the dependency graph.
var d=a.deps.map(function(a){return c.controllers.registry.getModuleState(a.id)===g.State.READY?c.controllers.registry.getModule(a.id).exports:b(c.controllers.builder.build(a.id)).exports});
// If the module itself is not yet built, then build it if there is a factory
// method that can be called.
return a.factory&&!a.hasOwnProperty("exports")&&(a.exports=a.factory.apply(void 0,d)),a}if(this._logger&&this._logger.log(a.name,a),!this.canProcess(a))throw new TypeError("Module "+a.name+" cannot be linked");var c=this.context,d=new g(a);
// Link it
// We will coerce the name no matter what name (if one at all) the Module was
// created with. This will ensure a consistent state in the loading engine.
// Set the mod.meta for convenience
return d.name=a.name,d.meta=a,b(d)},b.exports=d},{"../inherit":32,"../module":34,"../service":40,loggero:18}],46:[function(a,b,c){function d(a){g.call(this,a),this._logger=e}var e=a("loggero").create("service/precompile"),f=a("../inherit"),g=a("../service");f.base(d)["extends"](g),b.exports=d},{"../inherit":32,"../service":40,loggero:18}],47:[function(a,b,c){function d(a){h.call(this,a),this._logger=f}function e(a){var b={};return!a.path&&a.url&&(b.path=a.url&&a.url.href),!a.hasOwnProperty("id")&&a.path&&(b.id=a.path),a.configure(b)}var f=a("loggero").create("service/resolve"),g=a("../inherit"),h=a("../service");g.base(d)["extends"](h),d.prototype.runAsync=function(){return h.prototype.runAsync.apply(this,arguments).then(e)},d.prototype.canProcess=function(a){return this.canExecute(a)&&!a.hasOwnProperty("path")},b.exports=d},{"../inherit":32,"../service":40,loggero:18}],48:[function(a,b,c){function d(a){h.call(this,a),this._logger=e}var e=a("loggero").create("service/transform"),f=a("dis-isa"),g=a("../inherit"),h=a("../service");g.base(d)["extends"](h),d.prototype.canProcess=function(a){return this.canExecute(a)&&f.isString(a.source)},b.exports=d},{"../inherit":32,"../service":40,"dis-isa":53,loggero:18}],49:[function(a,b,c){(function(d){!function(a){if("object"==typeof c&&"undefined"!=typeof b)b.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof d?d:"undefined"!=typeof self?self:this,e.acorn=a()}}(function(){return function b(c,d,e){function f(h,i){if(!d[h]){if(!c[h]){var j="function"==typeof a&&a;if(!i&&j)return j(h,!0);if(g)return g(h,!0);var k=new Error("Cannot find module '"+h+"'");throw k.code="MODULE_NOT_FOUND",k}var l=d[h]={exports:{}};c[h][0].call(l.exports,function(a){var b=c[h][1][a];return f(b?b:a)},l,l.exports,b,c,d,e)}return d[h].exports}for(var g="function"==typeof a&&a,h=0;h<e.length;h++)f(e[h]);return f}({1:[function(a,b,c){
// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
"use strict";var d=a("./tokentype"),e=a("./state"),f=e.Parser.prototype;
// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.
f.checkPropClash=function(a,b){if(!(this.options.ecmaVersion>=6&&(a.computed||a.method||a.shorthand))){var c=a.key,d=void 0;switch(c.type){case"Identifier":d=c.name;break;case"Literal":d=String(c.value);break;default:return}var e=a.kind;if(this.options.ecmaVersion>=6)return void("__proto__"===d&&"init"===e&&(b.proto&&this.raise(c.start,"Redefinition of __proto__ property"),b.proto=!0));d="$"+d;var f=b[d];if(f){var g="init"!==e;(!this.strict&&!g||!f[e])&&g^f.init||this.raise(c.start,"Redefinition of property")}else f=b[d]={init:!1,get:!1,set:!1};f[e]=!0}},
// ### Expression parsing
// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).
f.parseExpression=function(a,b){var c=this.start,e=this.startLoc,f=this.parseMaybeAssign(a,b);if(this.type===d.types.comma){var g=this.startNodeAt(c,e);for(g.expressions=[f];this.eat(d.types.comma);)g.expressions.push(this.parseMaybeAssign(a,b));return this.finishNode(g,"SequenceExpression")}return f},
// Parse an assignment expression. This includes applications of
// operators like `+=`.
f.parseMaybeAssign=function(a,b,c){if(this.type==d.types._yield&&this.inGenerator)return this.parseYield();var e=!1;b||(b={shorthandAssign:0,trailingComma:0},e=!0);var f=this.start,g=this.startLoc;this.type!=d.types.parenL&&this.type!=d.types.name||(this.potentialArrowAt=this.start);var h=this.parseMaybeConditional(a,b);if(c&&(h=c.call(this,h,f,g)),this.type.isAssign){e&&this.checkPatternErrors(b,!0);var i=this.startNodeAt(f,g);// reset because shorthand default was used correctly
return i.operator=this.value,i.left=this.type===d.types.eq?this.toAssignable(h):h,b.shorthandAssign=0,this.checkLVal(h),this.next(),i.right=this.parseMaybeAssign(a),this.finishNode(i,"AssignmentExpression")}return e&&this.checkExpressionErrors(b,!0),h},
// Parse a ternary conditional (`?:`) operator.
f.parseMaybeConditional=function(a,b){var c=this.start,e=this.startLoc,f=this.parseExprOps(a,b);if(this.checkExpressionErrors(b))return f;if(this.eat(d.types.question)){var g=this.startNodeAt(c,e);return g.test=f,g.consequent=this.parseMaybeAssign(),this.expect(d.types.colon),g.alternate=this.parseMaybeAssign(a),this.finishNode(g,"ConditionalExpression")}return f},
// Start the precedence parser.
f.parseExprOps=function(a,b){var c=this.start,d=this.startLoc,e=this.parseMaybeUnary(b);return this.checkExpressionErrors(b)?e:this.parseExprOp(e,c,d,-1,a)},
// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
f.parseExprOp=function(a,b,c,e,f){var g=this.type.binop;if(null!=g&&(!f||this.type!==d.types._in)&&g>e){var h=this.startNodeAt(b,c);h.left=a,h.operator=this.value;var i=this.type;this.next();var j=this.start,k=this.startLoc;return h.right=this.parseExprOp(this.parseMaybeUnary(),j,k,g,f),this.finishNode(h,i===d.types.logicalOR||i===d.types.logicalAND?"LogicalExpression":"BinaryExpression"),this.parseExprOp(h,b,c,e,f)}return a},
// Parse unary operators, both prefix and postfix.
f.parseMaybeUnary=function(a){if(this.type.prefix){var b=this.startNode(),c=this.type===d.types.incDec;return b.operator=this.value,b.prefix=!0,this.next(),b.argument=this.parseMaybeUnary(),this.checkExpressionErrors(a,!0),c?this.checkLVal(b.argument):this.strict&&"delete"===b.operator&&"Identifier"===b.argument.type&&this.raise(b.start,"Deleting local variable in strict mode"),this.finishNode(b,c?"UpdateExpression":"UnaryExpression")}var e=this.start,f=this.startLoc,g=this.parseExprSubscripts(a);if(this.checkExpressionErrors(a))return g;for(;this.type.postfix&&!this.canInsertSemicolon();){var b=this.startNodeAt(e,f);b.operator=this.value,b.prefix=!1,b.argument=g,this.checkLVal(g),this.next(),g=this.finishNode(b,"UpdateExpression")}return g},
// Parse call, dot, and `[]`-subscript expressions.
f.parseExprSubscripts=function(a){var b=this.start,c=this.startLoc,d=this.parseExprAtom(a),e="ArrowFunctionExpression"===d.type&&")"!==this.input.slice(this.lastTokStart,this.lastTokEnd);return this.checkExpressionErrors(a)||e?d:this.parseSubscripts(d,b,c)},f.parseSubscripts=function(a,b,c,e){for(;;)if(this.eat(d.types.dot)){var f=this.startNodeAt(b,c);f.object=a,f.property=this.parseIdent(!0),f.computed=!1,a=this.finishNode(f,"MemberExpression")}else if(this.eat(d.types.bracketL)){var f=this.startNodeAt(b,c);f.object=a,f.property=this.parseExpression(),f.computed=!0,this.expect(d.types.bracketR),a=this.finishNode(f,"MemberExpression")}else if(!e&&this.eat(d.types.parenL)){var f=this.startNodeAt(b,c);f.callee=a,f.arguments=this.parseExprList(d.types.parenR,!1),a=this.finishNode(f,"CallExpression")}else{if(this.type!==d.types.backQuote)return a;var f=this.startNodeAt(b,c);f.tag=a,f.quasi=this.parseTemplate(),a=this.finishNode(f,"TaggedTemplateExpression")}},
// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.
f.parseExprAtom=function(a){var b=void 0,c=this.potentialArrowAt==this.start;switch(this.type){case d.types._super:this.inFunction||this.raise(this.start,"'super' outside of function or class");case d.types._this:var e=this.type===d.types._this?"ThisExpression":"Super";return b=this.startNode(),this.next(),this.finishNode(b,e);case d.types._yield:this.inGenerator&&this.unexpected();case d.types.name:var f=this.start,g=this.startLoc,h=this.parseIdent(this.type!==d.types.name);return c&&!this.canInsertSemicolon()&&this.eat(d.types.arrow)?this.parseArrowExpression(this.startNodeAt(f,g),[h]):h;case d.types.regexp:var i=this.value;return b=this.parseLiteral(i.value),b.regex={pattern:i.pattern,flags:i.flags},b;case d.types.num:case d.types.string:return this.parseLiteral(this.value);case d.types._null:case d.types._true:case d.types._false:return b=this.startNode(),b.value=this.type===d.types._null?null:this.type===d.types._true,b.raw=this.type.keyword,this.next(),this.finishNode(b,"Literal");case d.types.parenL:return this.parseParenAndDistinguishExpression(c);case d.types.bracketL:
// check whether this is array comprehension or regular array
// check whether this is array comprehension or regular array
return b=this.startNode(),this.next(),this.options.ecmaVersion>=7&&this.type===d.types._for?this.parseComprehension(b,!1):(b.elements=this.parseExprList(d.types.bracketR,!0,!0,a),this.finishNode(b,"ArrayExpression"));case d.types.braceL:return this.parseObj(!1,a);case d.types._function:return b=this.startNode(),this.next(),this.parseFunction(b,!1);case d.types._class:return this.parseClass(this.startNode(),!1);case d.types._new:return this.parseNew();case d.types.backQuote:return this.parseTemplate();default:this.unexpected()}},f.parseLiteral=function(a){var b=this.startNode();return b.value=a,b.raw=this.input.slice(this.start,this.end),this.next(),this.finishNode(b,"Literal")},f.parseParenExpression=function(){this.expect(d.types.parenL);var a=this.parseExpression();return this.expect(d.types.parenR),a},f.parseParenAndDistinguishExpression=function(a){var b=this.start,c=this.startLoc,e=void 0;if(this.options.ecmaVersion>=6){if(this.next(),this.options.ecmaVersion>=7&&this.type===d.types._for)return this.parseComprehension(this.startNodeAt(b,c),!0);for(var f=this.start,g=this.startLoc,h=[],i=!0,j={shorthandAssign:0,trailingComma:0},k=void 0,l=void 0;this.type!==d.types.parenR;){if(i?i=!1:this.expect(d.types.comma),this.type===d.types.ellipsis){k=this.start,h.push(this.parseParenItem(this.parseRest()));break}this.type!==d.types.parenL||l||(l=this.start),h.push(this.parseMaybeAssign(!1,j,this.parseParenItem))}var m=this.start,n=this.startLoc;if(this.expect(d.types.parenR),a&&!this.canInsertSemicolon()&&this.eat(d.types.arrow))return this.checkPatternErrors(j,!0),l&&this.unexpected(l),this.parseParenArrowList(b,c,h);h.length||this.unexpected(this.lastTokStart),k&&this.unexpected(k),this.checkExpressionErrors(j,!0),h.length>1?(e=this.startNodeAt(f,g),e.expressions=h,this.finishNodeAt(e,"SequenceExpression",m,n)):e=h[0]}else e=this.parseParenExpression();if(this.options.preserveParens){var o=this.startNodeAt(b,c);return o.expression=e,this.finishNode(o,"ParenthesizedExpression")}return e},f.parseParenItem=function(a){return a},f.parseParenArrowList=function(a,b,c){return this.parseArrowExpression(this.startNodeAt(a,b),c)};
// New's precedence is slightly tricky. It must allow its argument
// to be a `[]` or dot subscript expression, but not a call  at
// least, not without wrapping it in parentheses. Thus, it uses the
var g=[];f.parseNew=function(){var a=this.startNode(),b=this.parseIdent(!0);if(this.options.ecmaVersion>=6&&this.eat(d.types.dot))return a.meta=b,a.property=this.parseIdent(!0),"target"!==a.property.name&&this.raise(a.property.start,"The only valid meta property for new is new.target"),this.inFunction||this.raise(a.start,"new.target can only be used in functions"),this.finishNode(a,"MetaProperty");var c=this.start,e=this.startLoc;return a.callee=this.parseSubscripts(this.parseExprAtom(),c,e,!0),this.eat(d.types.parenL)?a.arguments=this.parseExprList(d.types.parenR,!1):a.arguments=g,this.finishNode(a,"NewExpression")},
// Parse template expression.
f.parseTemplateElement=function(){var a=this.startNode();return a.value={raw:this.input.slice(this.start,this.end).replace(/\r\n?/g,"\n"),cooked:this.value},this.next(),a.tail=this.type===d.types.backQuote,this.finishNode(a,"TemplateElement")},f.parseTemplate=function(){var a=this.startNode();this.next(),a.expressions=[];var b=this.parseTemplateElement();for(a.quasis=[b];!b.tail;)this.expect(d.types.dollarBraceL),a.expressions.push(this.parseExpression()),this.expect(d.types.braceR),a.quasis.push(b=this.parseTemplateElement());return this.next(),this.finishNode(a,"TemplateLiteral")},
// Parse an object literal or binding pattern.
f.parseObj=function(a,b){var c=this.startNode(),e=!0,f={};for(c.properties=[],this.next();!this.eat(d.types.braceR);){if(e)e=!1;else if(this.expect(d.types.comma),this.afterTrailingComma(d.types.braceR))break;var g=this.startNode(),h=void 0,i=void 0,j=void 0;this.options.ecmaVersion>=6&&(g.method=!1,g.shorthand=!1,(a||b)&&(i=this.start,j=this.startLoc),a||(h=this.eat(d.types.star))),this.parsePropertyName(g),this.parsePropertyValue(g,a,h,i,j,b),this.checkPropClash(g,f),c.properties.push(this.finishNode(g,"Property"))}return this.finishNode(c,a?"ObjectPattern":"ObjectExpression")},f.parsePropertyValue=function(a,b,c,e,f,g){if(this.eat(d.types.colon))a.value=b?this.parseMaybeDefault(this.start,this.startLoc):this.parseMaybeAssign(!1,g),a.kind="init";else if(this.options.ecmaVersion>=6&&this.type===d.types.parenL)b&&this.unexpected(),a.kind="init",a.method=!0,a.value=this.parseMethod(c);else if(this.options.ecmaVersion>=5&&!a.computed&&"Identifier"===a.key.type&&("get"===a.key.name||"set"===a.key.name)&&this.type!=d.types.comma&&this.type!=d.types.braceR){(c||b)&&this.unexpected(),a.kind=a.key.name,this.parsePropertyName(a),a.value=this.parseMethod(!1);var h="get"===a.kind?0:1;if(a.value.params.length!==h){var i=a.value.start;"get"===a.kind?this.raise(i,"getter should have no params"):this.raise(i,"setter should have exactly one param")}}else this.options.ecmaVersion>=6&&!a.computed&&"Identifier"===a.key.type?(a.kind="init",b?((this.keywords.test(a.key.name)||(this.strict?this.reservedWordsStrictBind:this.reservedWords).test(a.key.name))&&this.raise(a.key.start,"Binding "+a.key.name),a.value=this.parseMaybeDefault(e,f,a.key)):this.type===d.types.eq&&g?(g.shorthandAssign||(g.shorthandAssign=this.start),a.value=this.parseMaybeDefault(e,f,a.key)):a.value=a.key,a.shorthand=!0):this.unexpected()},f.parsePropertyName=function(a){if(this.options.ecmaVersion>=6){if(this.eat(d.types.bracketL))return a.computed=!0,a.key=this.parseMaybeAssign(),this.expect(d.types.bracketR),a.key;a.computed=!1}return a.key=this.type===d.types.num||this.type===d.types.string?this.parseExprAtom():this.parseIdent(!0)},
// Initialize empty function node.
f.initFunction=function(a){a.id=null,this.options.ecmaVersion>=6&&(a.generator=!1,a.expression=!1)},
// Parse object or class method.
f.parseMethod=function(a){var b=this.startNode();return this.initFunction(b),this.expect(d.types.parenL),b.params=this.parseBindingList(d.types.parenR,!1,!1),this.options.ecmaVersion>=6&&(b.generator=a),this.parseFunctionBody(b,!1),this.finishNode(b,"FunctionExpression")},
// Parse arrow function expression with given parameters.
f.parseArrowExpression=function(a,b){return this.initFunction(a),a.params=this.toAssignableList(b,!0),this.parseFunctionBody(a,!0),this.finishNode(a,"ArrowFunctionExpression")},
// Parse function body and check parameters.
f.parseFunctionBody=function(a,b){var c=b&&this.type!==d.types.braceL;if(c)a.body=this.parseMaybeAssign(),a.expression=!0;else{
// Start a new scope with regard to labels and the `inFunction`
// flag (restore them to their old value afterwards).
var e=this.inFunction,f=this.inGenerator,g=this.labels;this.inFunction=!0,this.inGenerator=a.generator,this.labels=[],a.body=this.parseBlock(!0),a.expression=!1,this.inFunction=e,this.inGenerator=f,this.labels=g}
// If this is a strict mode function, verify that argument names
// are not repeated, and it does not try to bind the words `eval`
// or `arguments`.
if(this.strict||!c&&a.body.body.length&&this.isUseStrict(a.body.body[0])){var h=this.strict;this.strict=!0,a.id&&this.checkLVal(a.id,!0),this.checkParams(a),this.strict=h}else b&&this.checkParams(a)},
// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.
f.checkParams=function(a){for(var b={},c=0;c<a.params.length;c++)this.checkLVal(a.params[c],!0,b)},
// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).
f.parseExprList=function(a,b,c,e){for(var f=[],g=!0;!this.eat(a);){if(g)g=!1;else if(this.expect(d.types.comma),this.type===a&&e&&!e.trailingComma&&(e.trailingComma=this.lastTokStart),b&&this.afterTrailingComma(a))break;var h=void 0;h=c&&this.type===d.types.comma?null:this.type===d.types.ellipsis?this.parseSpread(e):this.parseMaybeAssign(!1,e),f.push(h)}return f},
// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.
f.parseIdent=function(a){var b=this.startNode();return a&&"never"==this.options.allowReserved&&(a=!1),this.type===d.types.name?(!a&&(this.strict?this.reservedWordsStrict:this.reservedWords).test(this.value)&&(this.options.ecmaVersion>=6||-1==this.input.slice(this.start,this.end).indexOf("\\"))&&this.raise(this.start,"The keyword '"+this.value+"' is reserved"),b.name=this.value):a&&this.type.keyword?b.name=this.type.keyword:this.unexpected(),this.next(),this.finishNode(b,"Identifier")},
// Parses yield expression inside generator.
f.parseYield=function(){var a=this.startNode();return this.next(),this.type==d.types.semi||this.canInsertSemicolon()||this.type!=d.types.star&&!this.type.startsExpr?(a.delegate=!1,a.argument=null):(a.delegate=this.eat(d.types.star),a.argument=this.parseMaybeAssign()),this.finishNode(a,"YieldExpression")},
// Parses array and generator comprehensions.
f.parseComprehension=function(a,b){for(a.blocks=[];this.type===d.types._for;){var c=this.startNode();this.next(),this.expect(d.types.parenL),c.left=this.parseBindingAtom(),this.checkLVal(c.left,!0),this.expectContextual("of"),c.right=this.parseExpression(),this.expect(d.types.parenR),a.blocks.push(this.finishNode(c,"ComprehensionBlock"))}return a.filter=this.eat(d.types._if)?this.parseParenExpression():null,a.body=this.parseExpression(),this.expect(b?d.types.parenR:d.types.bracketR),a.generator=b,this.finishNode(a,"ComprehensionExpression")}},{"./state":10,"./tokentype":14}],2:[function(a,b,c){
// This is a trick taken from Esprima. It turns out that, on
// non-Chrome browsers, to check whether a string is in a set, a
// predicate containing a big ugly `switch` statement is faster than
// a regular expression, and on Chrome the two are about on par.
// This function uses `eval` (non-lexical) to produce such a
// predicate from a space-separated string of words.
//
// It starts by sorting the words by length.
// Reserved word lists for various dialects of the language
"use strict";
// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function d(a,b){for(var c=65536,d=0;d<b.length;d+=2){if(c+=b[d],c>a)return!1;if(c+=b[d+1],c>=a)return!0}}
// Test whether a given character code starts an identifier.
function e(a,b){return 65>a?36===a:91>a?!0:97>a?95===a:123>a?!0:65535>=a?a>=170&&l.test(String.fromCharCode(a)):b===!1?!1:d(a,n)}
// Test whether a given character is part of an identifier.
function f(a,b){return 48>a?36===a:58>a?!0:65>a?!1:91>a?!0:97>a?95===a:123>a?!0:65535>=a?a>=170&&m.test(String.fromCharCode(a)):b===!1?!1:d(a,n)||d(a,o)}c.__esModule=!0,c.isIdentifierStart=e,c.isIdentifierChar=f;var g={3:"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",5:"class enum extends super const export import",6:"enum",strict:"implements interface let package private protected public static yield",strictBind:"eval arguments"};c.reservedWords=g;
// And the keywords
var h="break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",i={5:h,6:h+" let const class extends export import yield super"};c.keywords=i;
// ## Character categories
// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var j="-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",k="-------------------------------------------------------------------------------------------------------------------------------------------------",l=new RegExp("["+j+"]"),m=new RegExp("["+j+k+"]");j=k=null;
// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by tools/generate-identifier-regex.js
var n=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,99,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,98,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,955,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,38,17,2,24,133,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,32,4,287,47,21,1,2,0,185,46,82,47,21,0,60,42,502,63,32,0,449,56,1288,920,104,110,2962,1070,13266,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,16481,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,1340,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,16355,541],o=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,16,9,83,11,168,11,6,9,8,2,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,316,19,13,9,214,6,3,8,112,16,16,9,82,12,9,9,535,9,20855,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,4305,6,792618,239]},{}],3:[function(a,b,c){
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/ternjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/ternjs/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js
"use strict";
// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
function d(a,b){return new g.Parser(b,a).parse()}
// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.
function e(a,b,c){var d=new g.Parser(c,a,b);return d.nextToken(),d.parseExpression()}
// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.
function f(a,b){return new g.Parser(b,a)}c.__esModule=!0,c.parse=d,c.parseExpressionAt=e,c.tokenizer=f;var g=a("./state");a("./parseutil"),a("./statement"),a("./lval"),a("./expression"),a("./location"),c.Parser=g.Parser,c.plugins=g.plugins;var h=a("./options");c.defaultOptions=h.defaultOptions;var i=a("./locutil");c.Position=i.Position,c.SourceLocation=i.SourceLocation,c.getLineInfo=i.getLineInfo;var j=a("./node");c.Node=j.Node;var k=a("./tokentype");c.TokenType=k.TokenType,c.tokTypes=k.types;var l=a("./tokencontext");c.TokContext=l.TokContext,c.tokContexts=l.types;var m=a("./identifier");c.isIdentifierChar=m.isIdentifierChar,c.isIdentifierStart=m.isIdentifierStart;var n=a("./tokenize");c.Token=n.Token;var o=a("./whitespace");c.isNewLine=o.isNewLine,c.lineBreak=o.lineBreak,c.lineBreakG=o.lineBreakG;var p="2.6.4";c.version=p},{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(a,b,c){"use strict";var d=a("./state"),e=a("./locutil"),f=d.Parser.prototype;
// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.
f.raise=function(a,b){var c=e.getLineInfo(this.input,a);b+=" ("+c.line+":"+c.column+")";var d=new SyntaxError(b);throw d.pos=a,d.loc=c,d.raisedAt=this.pos,d},f.curPosition=function(){return this.options.locations?new e.Position(this.curLine,this.pos-this.lineStart):void 0}},{"./locutil":5,"./state":10}],5:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(a,b){for(var c=1,d=0;;){f.lineBreakG.lastIndex=d;var e=f.lineBreakG.exec(a);if(!(e&&e.index<b))return new g(c,b-d);++c,d=e.index+e[0].length}}c.__esModule=!0,c.getLineInfo=e;var f=a("./whitespace"),g=function(){function a(b,c){d(this,a),this.line=b,this.column=c}return a.prototype.offset=function(b){return new a(this.line,this.column+b)},a}();c.Position=g;var h=function i(a,b,c){d(this,i),this.start=b,this.end=c,null!==a.sourceFile&&(this.source=a.sourceFile)};c.SourceLocation=h},{"./whitespace":16}],6:[function(a,b,c){"use strict";var d=a("./tokentype"),e=a("./state"),f=a("./util"),g=e.Parser.prototype;
// Convert existing expression atom to assignable pattern
// if possible.
g.toAssignable=function(a,b){if(this.options.ecmaVersion>=6&&a)switch(a.type){case"Identifier":case"ObjectPattern":case"ArrayPattern":break;case"ObjectExpression":a.type="ObjectPattern";for(var c=0;c<a.properties.length;c++){var d=a.properties[c];"init"!==d.kind&&this.raise(d.key.start,"Object pattern can't contain getter or setter"),this.toAssignable(d.value,b)}break;case"ArrayExpression":a.type="ArrayPattern",this.toAssignableList(a.elements,b);break;case"AssignmentExpression":if("="!==a.operator){this.raise(a.left.end,"Only '=' operator can be used for specifying default value.");break}a.type="AssignmentPattern",delete a.operator;case"AssignmentPattern":"YieldExpression"===a.right.type&&this.raise(a.right.start,"Yield expression cannot be a default value");break;case"ParenthesizedExpression":a.expression=this.toAssignable(a.expression,b);break;case"MemberExpression":if(!b)break;default:this.raise(a.start,"Assigning to rvalue")}return a},
// Convert list of expression atoms to binding list.
g.toAssignableList=function(a,b){var c=a.length;if(c){var d=a[c-1];if(d&&"RestElement"==d.type)--c;else if(d&&"SpreadElement"==d.type){d.type="RestElement";var e=d.argument;this.toAssignable(e,b),"Identifier"!==e.type&&"MemberExpression"!==e.type&&"ArrayPattern"!==e.type&&this.unexpected(e.start),--c}b&&"RestElement"===d.type&&"Identifier"!==d.argument.type&&this.unexpected(d.argument.start)}for(var f=0;c>f;f++){var g=a[f];g&&this.toAssignable(g,b)}return a},
// Parses spread element.
g.parseSpread=function(a){var b=this.startNode();return this.next(),b.argument=this.parseMaybeAssign(a),this.finishNode(b,"SpreadElement")},g.parseRest=function(a){var b=this.startNode();
// RestElement inside of a function parameter must be an identifier
return this.next(),a?b.argument=this.type===d.types.name?this.parseIdent():this.unexpected():b.argument=this.type===d.types.name||this.type===d.types.bracketL?this.parseBindingAtom():this.unexpected(),this.finishNode(b,"RestElement")},
// Parses lvalue (assignable) atom.
g.parseBindingAtom=function(){if(this.options.ecmaVersion<6)return this.parseIdent();switch(this.type){case d.types.name:return this.parseIdent();case d.types.bracketL:var a=this.startNode();return this.next(),a.elements=this.parseBindingList(d.types.bracketR,!0,!0),this.finishNode(a,"ArrayPattern");case d.types.braceL:return this.parseObj(!0);default:this.unexpected()}},g.parseBindingList=function(a,b,c,e){for(var f=[],g=!0;!this.eat(a);)if(g?g=!1:this.expect(d.types.comma),b&&this.type===d.types.comma)f.push(null);else{if(c&&this.afterTrailingComma(a))break;if(this.type===d.types.ellipsis){var h=this.parseRest(e);this.parseBindingListItem(h),f.push(h),this.expect(a);break}var i=this.parseMaybeDefault(this.start,this.startLoc);this.parseBindingListItem(i),f.push(i)}return f},g.parseBindingListItem=function(a){return a},
// Parses assignment pattern around given atom if possible.
g.parseMaybeDefault=function(a,b,c){if(c=c||this.parseBindingAtom(),this.options.ecmaVersion<6||!this.eat(d.types.eq))return c;var e=this.startNodeAt(a,b);return e.left=c,e.right=this.parseMaybeAssign(),this.finishNode(e,"AssignmentPattern")},
// Verify that a node is an lval  something that can be assigned
// to.
g.checkLVal=function(a,b,c){switch(a.type){case"Identifier":this.strict&&this.reservedWordsStrictBind.test(a.name)&&this.raise(a.start,(b?"Binding ":"Assigning to ")+a.name+" in strict mode"),c&&(f.has(c,a.name)&&this.raise(a.start,"Argument name clash"),c[a.name]=!0);break;case"MemberExpression":b&&this.raise(a.start,(b?"Binding":"Assigning to")+" member expression");break;case"ObjectPattern":for(var d=0;d<a.properties.length;d++)this.checkLVal(a.properties[d].value,b,c);break;case"ArrayPattern":for(var d=0;d<a.elements.length;d++){var e=a.elements[d];e&&this.checkLVal(e,b,c)}break;case"AssignmentPattern":this.checkLVal(a.left,b,c);break;case"RestElement":this.checkLVal(a.argument,b,c);break;case"ParenthesizedExpression":this.checkLVal(a.expression,b,c);break;default:this.raise(a.start,(b?"Binding":"Assigning to")+" rvalue")}}},{"./state":10,"./tokentype":14,"./util":15}],7:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}
// Finish an AST node, adding `type` and `end` properties.
function e(a,b,c,d){return a.type=b,a.end=c,this.options.locations&&(a.loc.end=d),this.options.ranges&&(a.range[1]=c),a}c.__esModule=!0;var f=a("./state"),g=a("./locutil"),h=function j(a,b,c){d(this,j),this.type="",this.start=b,this.end=0,a.options.locations&&(this.loc=new g.SourceLocation(a,c)),a.options.directSourceFile&&(this.sourceFile=a.options.directSourceFile),a.options.ranges&&(this.range=[b,0])};c.Node=h;var i=f.Parser.prototype;i.startNode=function(){return new h(this,this.start,this.startLoc)},i.startNodeAt=function(a,b){return new h(this,a,b)},i.finishNode=function(a,b){return e.call(this,a,b,this.lastTokEnd,this.lastTokEndLoc)},
// Finish node at given position
i.finishNodeAt=function(a,b,c,d){return e.call(this,a,b,c,d)}},{"./locutil":5,"./state":10}],8:[function(a,b,c){"use strict";
// Interpret and default an options object
function d(a){var b={};for(var c in h)b[c]=a&&f.has(a,c)?a[c]:h[c];return null==b.allowReserved&&(b.allowReserved=b.ecmaVersion<5),f.isArray(b.onToken)&&!function(){var a=b.onToken;b.onToken=function(b){return a.push(b)}}(),f.isArray(b.onComment)&&(b.onComment=e(b,b.onComment)),b}function e(a,b){return function(c,d,e,f,h,i){var j={type:c?"Block":"Line",value:d,start:e,end:f};a.locations&&(j.loc=new g.SourceLocation(this,h,i)),a.ranges&&(j.range=[e,f]),b.push(j)}}c.__esModule=!0,c.getOptions=d;var f=a("./util"),g=a("./locutil"),h={
// `ecmaVersion` indicates the ECMAScript version to parse. Must
// be either 3, or 5, or 6. This influences support for strict
// mode, the set of reserved words, support for getters and
// setters and other features.
ecmaVersion:5,
// Source type ("script" or "module") for different semantics
sourceType:"script",
// `onInsertedSemicolon` can be a callback that will be called
// when a semicolon is automatically inserted. It will be passed
// th position of the comma as an offset, and if `locations` is
// enabled, it is given the location as a `{line, column}` object
// as second argument.
onInsertedSemicolon:null,
// `onTrailingComma` is similar to `onInsertedSemicolon`, but for
// trailing commas.
onTrailingComma:null,
// By default, reserved words are only enforced if ecmaVersion >= 5.
// Set `allowReserved` to a boolean value to explicitly turn this on
// an off. When this option has the value "never", reserved words
// and keywords can also not be used as property names.
allowReserved:null,
// When enabled, a return at the top level is not considered an
// error.
allowReturnOutsideFunction:!1,
// When enabled, import/export statements are not constrained to
// appearing at the top of the program.
allowImportExportEverywhere:!1,
// When enabled, hashbang directive in the beginning of file
// is allowed and treated as a line comment.
allowHashBang:!1,
// When `locations` is on, `loc` properties holding objects with
// `start` and `end` properties in `{line, column}` form (with
// line being 1-based and column 0-based) will be attached to the
// nodes.
locations:!1,
// A function can be passed as `onToken` option, which will
// cause Acorn to call that function with object in the same
// format as tokens returned from `tokenizer().getToken()`. Note
// that you are not allowed to call the parser from the
// callbackthat will corrupt its internal state.
onToken:null,
// A function can be passed as `onComment` option, which will
// cause Acorn to call that function with `(block, text, start,
// end)` parameters whenever a comment is skipped. `block` is a
// boolean indicating whether this is a block (`/* */`) comment,
// `text` is the content of the comment, and `start` and `end` are
// character offsets that denote the start and end of the comment.
// When the `locations` option is on, two more parameters are
// passed, the full `{line, column}` locations of the start and
// end of the comments. Note that you are not allowed to call the
// parser from the callbackthat will corrupt its internal state.
onComment:null,
// Nodes have their start and end characters offsets recorded in
// `start` and `end` properties (directly on the node, rather than
// the `loc` object, which holds line/column data. To also add a
// [semi-standardized][range] `range` property holding a `[start,
// end]` array with the same numbers, set the `ranges` option to
// `true`.
//
// [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
ranges:!1,
// It is possible to parse multiple files into a single AST by
// passing the tree produced by parsing the first file as
// `program` option in subsequent parses. This will add the
// toplevel forms of the parsed file to the `Program` (top) node
// of an existing parse tree.
program:null,
// When `locations` is on, you can pass this to record the source
// file in every node's `loc` object.
sourceFile:null,
// This value, if given, is stored in every node, whether
// `locations` is on or off.
directSourceFile:null,
// When enabled, parenthesized expressions are represented by
// (non-standard) ParenthesizedExpression nodes
preserveParens:!1,plugins:{}};c.defaultOptions=h},{"./locutil":5,"./util":15}],9:[function(a,b,c){"use strict";var d=a("./tokentype"),e=a("./state"),f=a("./whitespace"),g=e.Parser.prototype;
// ## Parser utilities
// Test whether a statement node is the string literal `"use strict"`.
g.isUseStrict=function(a){return this.options.ecmaVersion>=5&&"ExpressionStatement"===a.type&&"Literal"===a.expression.type&&"use strict"===a.expression.raw.slice(1,-1)},
// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.
g.eat=function(a){return this.type===a?(this.next(),!0):!1},
// Tests whether parsed token is a contextual keyword.
g.isContextual=function(a){return this.type===d.types.name&&this.value===a},
// Consumes contextual keyword if possible.
g.eatContextual=function(a){return this.value===a&&this.eat(d.types.name)},
// Asserts that following token is given contextual keyword.
g.expectContextual=function(a){this.eatContextual(a)||this.unexpected()},
// Test whether a semicolon can be inserted at the current position.
g.canInsertSemicolon=function(){return this.type===d.types.eof||this.type===d.types.braceR||f.lineBreak.test(this.input.slice(this.lastTokEnd,this.start))},g.insertSemicolon=function(){return this.canInsertSemicolon()?(this.options.onInsertedSemicolon&&this.options.onInsertedSemicolon(this.lastTokEnd,this.lastTokEndLoc),!0):void 0},
// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.
g.semicolon=function(){this.eat(d.types.semi)||this.insertSemicolon()||this.unexpected()},g.afterTrailingComma=function(a){return this.type==a?(this.options.onTrailingComma&&this.options.onTrailingComma(this.lastTokStart,this.lastTokStartLoc),this.next(),!0):void 0},
// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.
g.expect=function(a){this.eat(a)||this.unexpected()},
// Raise an unexpected token error.
g.unexpected=function(a){this.raise(null!=a?a:this.start,"Unexpected token")},g.checkPatternErrors=function(a,b){var c=a&&a.trailingComma;return b?void(c&&this.raise(c,"Trailing comma is not permitted in destructuring patterns")):!!c},g.checkExpressionErrors=function(a,b){var c=a&&a.shorthandAssign;return b?void(c&&this.raise(c,"Shorthand property assignments are valid only in destructuring patterns")):!!c}},{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(a){return new RegExp("^("+a.replace(/ /g,"|")+")$")}c.__esModule=!0;var f=a("./identifier"),g=a("./tokentype"),h=a("./whitespace"),i=a("./options"),j={};c.plugins=j;var k=function(){function a(b,c,j){d(this,a),this.options=b=i.getOptions(b),this.sourceFile=b.sourceFile,this.keywords=e(f.keywords[b.ecmaVersion>=6?6:5]);var k=b.allowReserved?"":f.reservedWords[b.ecmaVersion]+("module"==b.sourceType?" await":"");this.reservedWords=e(k);var l=(k?k+" ":"")+f.reservedWords.strict;this.reservedWordsStrict=e(l),this.reservedWordsStrictBind=e(l+" "+f.reservedWords.strictBind),this.input=String(c),
// Used to signal to callers of `readWord1` whether the word
// contained any escape sequences. This is needed because words with
// escape sequences must not be interpreted as keywords.
this.containsEsc=!1,
// Load plugins
this.loadPlugins(b.plugins),
// Set up token state
// The current position of the tokenizer in the input.
j?(this.pos=j,this.lineStart=Math.max(0,this.input.lastIndexOf("\n",j)),this.curLine=this.input.slice(0,this.lineStart).split(h.lineBreak).length):(this.pos=this.lineStart=0,this.curLine=1),
// Properties of the current token:
// Its type
this.type=g.types.eof,
// For tokens that include more information than their type, the value
this.value=null,
// Its start and end offset
this.start=this.end=this.pos,
// And, if locations are used, the {line, column} object
// corresponding to those offsets
this.startLoc=this.endLoc=this.curPosition(),
// Position information for the previous token
this.lastTokEndLoc=this.lastTokStartLoc=null,this.lastTokStart=this.lastTokEnd=this.pos,
// The context stack is used to superficially track syntactic
// context to predict whether a regular expression is allowed in a
// given position.
this.context=this.initialContext(),this.exprAllowed=!0,
// Figure out if it's a module code.
this.strict=this.inModule="module"===b.sourceType,
// Used to signify the start of a potential arrow function
this.potentialArrowAt=-1,
// Flags to track whether we are in a function, a generator.
this.inFunction=this.inGenerator=!1,
// Labels in scope.
this.labels=[],
// If enabled, skip leading hashbang line.
0===this.pos&&b.allowHashBang&&"#!"===this.input.slice(0,2)&&this.skipLineComment(2)}
// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
return a.prototype.isKeyword=function(a){return this.keywords.test(a)},a.prototype.isReservedWord=function(a){return this.reservedWords.test(a)},a.prototype.extend=function(a,b){this[a]=b(this[a])},a.prototype.loadPlugins=function(a){for(var b in a){var c=j[b];if(!c)throw new Error("Plugin '"+b+"' not found");c(this,a[b])}},a.prototype.parse=function(){var a=this.options.program||this.startNode();return this.nextToken(),this.parseTopLevel(a)},a}();c.Parser=k},{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(a,b,c){"use strict";var d=a("./tokentype"),e=a("./state"),f=a("./whitespace"),g=e.Parser.prototype;
// ### Statement parsing
// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.
g.parseTopLevel=function(a){var b=!0;for(a.body||(a.body=[]);this.type!==d.types.eof;){var c=this.parseStatement(!0,!0);a.body.push(c),b&&(this.isUseStrict(c)&&this.setStrict(!0),b=!1)}return this.next(),this.options.ecmaVersion>=6&&(a.sourceType=this.options.sourceType),this.finishNode(a,"Program")};var h={kind:"loop"},i={kind:"switch"};
// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.
g.parseStatement=function(a,b){var c=this.type,e=this.startNode();
// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.
switch(c){case d.types._break:case d.types._continue:return this.parseBreakContinueStatement(e,c.keyword);case d.types._debugger:return this.parseDebuggerStatement(e);case d.types._do:return this.parseDoStatement(e);case d.types._for:return this.parseForStatement(e);case d.types._function:return!a&&this.options.ecmaVersion>=6&&this.unexpected(),this.parseFunctionStatement(e);case d.types._class:return a||this.unexpected(),this.parseClass(e,!0);case d.types._if:return this.parseIfStatement(e);case d.types._return:return this.parseReturnStatement(e);case d.types._switch:return this.parseSwitchStatement(e);case d.types._throw:return this.parseThrowStatement(e);case d.types._try:return this.parseTryStatement(e);case d.types._let:case d.types._const:a||this.unexpected();// NOTE: falls through to _var
case d.types._var:return this.parseVarStatement(e,c);case d.types._while:return this.parseWhileStatement(e);case d.types._with:return this.parseWithStatement(e);case d.types.braceL:return this.parseBlock();case d.types.semi:return this.parseEmptyStatement(e);case d.types._export:case d.types._import:return this.options.allowImportExportEverywhere||(b||this.raise(this.start,"'import' and 'export' may only appear at the top level"),this.inModule||this.raise(this.start,"'import' and 'export' may appear only with 'sourceType: module'")),c===d.types._import?this.parseImport(e):this.parseExport(e);
// If the statement does not start with a statement keyword or a
// brace, it's an ExpressionStatement or LabeledStatement. We
// simply start parsing an expression, and afterwards, if the
// next token is a colon and the expression was a simple
// Identifier node, we switch to interpreting it as a label.
default:var f=this.value,g=this.parseExpression();return c===d.types.name&&"Identifier"===g.type&&this.eat(d.types.colon)?this.parseLabeledStatement(e,f,g):this.parseExpressionStatement(e,g)}},g.parseBreakContinueStatement=function(a,b){var c="break"==b;this.next(),this.eat(d.types.semi)||this.insertSemicolon()?a.label=null:this.type!==d.types.name?this.unexpected():(a.label=this.parseIdent(),this.semicolon());
// Verify that there is an actual destination to break or
// continue to.
for(var e=0;e<this.labels.length;++e){var f=this.labels[e];if(null==a.label||f.name===a.label.name){if(null!=f.kind&&(c||"loop"===f.kind))break;if(a.label&&c)break}}return e===this.labels.length&&this.raise(a.start,"Unsyntactic "+b),this.finishNode(a,c?"BreakStatement":"ContinueStatement")},g.parseDebuggerStatement=function(a){return this.next(),this.semicolon(),this.finishNode(a,"DebuggerStatement")},g.parseDoStatement=function(a){return this.next(),this.labels.push(h),a.body=this.parseStatement(!1),this.labels.pop(),this.expect(d.types._while),a.test=this.parseParenExpression(),this.options.ecmaVersion>=6?this.eat(d.types.semi):this.semicolon(),this.finishNode(a,"DoWhileStatement")},
// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.
g.parseForStatement=function(a){if(this.next(),this.labels.push(h),this.expect(d.types.parenL),this.type===d.types.semi)return this.parseFor(a,null);if(this.type===d.types._var||this.type===d.types._let||this.type===d.types._const){var b=this.startNode(),c=this.type;return this.next(),this.parseVar(b,!0,c),this.finishNode(b,"VariableDeclaration"),!(this.type===d.types._in||this.options.ecmaVersion>=6&&this.isContextual("of"))||1!==b.declarations.length||c!==d.types._var&&b.declarations[0].init?this.parseFor(a,b):this.parseForIn(a,b)}var e={shorthandAssign:0,trailingComma:0},f=this.parseExpression(!0,e);return this.type===d.types._in||this.options.ecmaVersion>=6&&this.isContextual("of")?(this.checkPatternErrors(e,!0),this.toAssignable(f),this.checkLVal(f),this.parseForIn(a,f)):(this.checkExpressionErrors(e,!0),this.parseFor(a,f))},g.parseFunctionStatement=function(a){return this.next(),this.parseFunction(a,!0)},g.parseIfStatement=function(a){return this.next(),a.test=this.parseParenExpression(),a.consequent=this.parseStatement(!1),a.alternate=this.eat(d.types._else)?this.parseStatement(!1):null,this.finishNode(a,"IfStatement")},g.parseReturnStatement=function(a){
// In `return` (and `break`/`continue`), the keywords with
// optional arguments, we eagerly look for a semicolon or the
// possibility to insert one.
return this.inFunction||this.options.allowReturnOutsideFunction||this.raise(this.start,"'return' outside of function"),this.next(),this.eat(d.types.semi)||this.insertSemicolon()?a.argument=null:(a.argument=this.parseExpression(),this.semicolon()),this.finishNode(a,"ReturnStatement")},g.parseSwitchStatement=function(a){this.next(),a.discriminant=this.parseParenExpression(),a.cases=[],this.expect(d.types.braceL),this.labels.push(i);
// Statements under must be grouped (by label) in SwitchCase
// nodes. `cur` is used to keep the node that we are currently
// adding statements to.
for(var b,c=!1;this.type!=d.types.braceR;)if(this.type===d.types._case||this.type===d.types._default){var e=this.type===d.types._case;b&&this.finishNode(b,"SwitchCase"),a.cases.push(b=this.startNode()),b.consequent=[],this.next(),e?b.test=this.parseExpression():(c&&this.raise(this.lastTokStart,"Multiple default clauses"),c=!0,b.test=null),this.expect(d.types.colon)}else b||this.unexpected(),b.consequent.push(this.parseStatement(!0));// Closing brace
return b&&this.finishNode(b,"SwitchCase"),this.next(),this.labels.pop(),this.finishNode(a,"SwitchStatement")},g.parseThrowStatement=function(a){return this.next(),f.lineBreak.test(this.input.slice(this.lastTokEnd,this.start))&&this.raise(this.lastTokEnd,"Illegal newline after throw"),a.argument=this.parseExpression(),this.semicolon(),this.finishNode(a,"ThrowStatement")};
// Reused empty array added for node fields that are always empty.
var j=[];g.parseTryStatement=function(a){if(this.next(),a.block=this.parseBlock(),a.handler=null,this.type===d.types._catch){var b=this.startNode();this.next(),this.expect(d.types.parenL),b.param=this.parseBindingAtom(),this.checkLVal(b.param,!0),this.expect(d.types.parenR),b.body=this.parseBlock(),a.handler=this.finishNode(b,"CatchClause")}return a.finalizer=this.eat(d.types._finally)?this.parseBlock():null,a.handler||a.finalizer||this.raise(a.start,"Missing catch or finally clause"),this.finishNode(a,"TryStatement")},g.parseVarStatement=function(a,b){return this.next(),this.parseVar(a,!1,b),this.semicolon(),this.finishNode(a,"VariableDeclaration")},g.parseWhileStatement=function(a){return this.next(),a.test=this.parseParenExpression(),this.labels.push(h),a.body=this.parseStatement(!1),this.labels.pop(),this.finishNode(a,"WhileStatement")},g.parseWithStatement=function(a){return this.strict&&this.raise(this.start,"'with' in strict mode"),this.next(),a.object=this.parseParenExpression(),a.body=this.parseStatement(!1),this.finishNode(a,"WithStatement")},g.parseEmptyStatement=function(a){return this.next(),this.finishNode(a,"EmptyStatement")},g.parseLabeledStatement=function(a,b,c){for(var e=0;e<this.labels.length;++e)this.labels[e].name===b&&this.raise(c.start,"Label '"+b+"' is already declared");for(var f=this.type.isLoop?"loop":this.type===d.types._switch?"switch":null,e=this.labels.length-1;e>=0;e--){var g=this.labels[e];if(g.statementStart!=a.start)break;g.statementStart=this.start,g.kind=f}return this.labels.push({name:b,kind:f,statementStart:this.start}),a.body=this.parseStatement(!0),this.labels.pop(),a.label=c,this.finishNode(a,"LabeledStatement")},g.parseExpressionStatement=function(a,b){return a.expression=b,this.semicolon(),this.finishNode(a,"ExpressionStatement")},
// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).
g.parseBlock=function(a){var b=this.startNode(),c=!0,e=void 0;for(b.body=[],this.expect(d.types.braceL);!this.eat(d.types.braceR);){var f=this.parseStatement(!0);b.body.push(f),c&&a&&this.isUseStrict(f)&&(e=this.strict,this.setStrict(this.strict=!0)),c=!1}return e===!1&&this.setStrict(!1),this.finishNode(b,"BlockStatement")},
// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.
g.parseFor=function(a,b){return a.init=b,this.expect(d.types.semi),a.test=this.type===d.types.semi?null:this.parseExpression(),this.expect(d.types.semi),a.update=this.type===d.types.parenR?null:this.parseExpression(),this.expect(d.types.parenR),a.body=this.parseStatement(!1),this.labels.pop(),this.finishNode(a,"ForStatement")},
// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.
g.parseForIn=function(a,b){var c=this.type===d.types._in?"ForInStatement":"ForOfStatement";return this.next(),a.left=b,a.right=this.parseExpression(),this.expect(d.types.parenR),a.body=this.parseStatement(!1),this.labels.pop(),this.finishNode(a,c)},
// Parse a list of variable declarations.
g.parseVar=function(a,b,c){for(a.declarations=[],a.kind=c.keyword;;){var e=this.startNode();if(this.parseVarId(e),this.eat(d.types.eq)?e.init=this.parseMaybeAssign(b):c!==d.types._const||this.type===d.types._in||this.options.ecmaVersion>=6&&this.isContextual("of")?"Identifier"==e.id.type||b&&(this.type===d.types._in||this.isContextual("of"))?e.init=null:this.raise(this.lastTokEnd,"Complex binding patterns require an initialization value"):this.unexpected(),a.declarations.push(this.finishNode(e,"VariableDeclarator")),!this.eat(d.types.comma))break}return a},g.parseVarId=function(a){a.id=this.parseBindingAtom(),this.checkLVal(a.id,!0)},
// Parse a function declaration or literal (depending on the
// `isStatement` parameter).
g.parseFunction=function(a,b,c){return this.initFunction(a),this.options.ecmaVersion>=6&&(a.generator=this.eat(d.types.star)),(b||this.type===d.types.name)&&(a.id=this.parseIdent()),this.parseFunctionParams(a),this.parseFunctionBody(a,c),this.finishNode(a,b?"FunctionDeclaration":"FunctionExpression")},g.parseFunctionParams=function(a){this.expect(d.types.parenL),a.params=this.parseBindingList(d.types.parenR,!1,!1,!0)},
// Parse a class declaration or literal (depending on the
// `isStatement` parameter).
g.parseClass=function(a,b){this.next(),this.parseClassId(a,b),this.parseClassSuper(a);var c=this.startNode(),e=!1;for(c.body=[],this.expect(d.types.braceL);!this.eat(d.types.braceR);)if(!this.eat(d.types.semi)){var f=this.startNode(),g=this.eat(d.types.star),h=this.type===d.types.name&&"static"===this.value;this.parsePropertyName(f),f["static"]=h&&this.type!==d.types.parenL,f["static"]&&(g&&this.unexpected(),g=this.eat(d.types.star),this.parsePropertyName(f)),f.kind="method";var i=!1;if(!f.computed){var j=f.key;g||"Identifier"!==j.type||this.type===d.types.parenL||"get"!==j.name&&"set"!==j.name||(i=!0,f.kind=j.name,j=this.parsePropertyName(f)),!f["static"]&&("Identifier"===j.type&&"constructor"===j.name||"Literal"===j.type&&"constructor"===j.value)&&(e&&this.raise(j.start,"Duplicate constructor in the same class"),i&&this.raise(j.start,"Constructor can't have get/set modifier"),g&&this.raise(j.start,"Constructor can't be a generator"),f.kind="constructor",e=!0)}if(this.parseClassMethod(c,f,g),i){var k="get"===f.kind?0:1;if(f.value.params.length!==k){var l=f.value.start;"get"===f.kind?this.raise(l,"getter should have no params"):this.raise(l,"setter should have exactly one param")}}}return a.body=this.finishNode(c,"ClassBody"),this.finishNode(a,b?"ClassDeclaration":"ClassExpression")},g.parseClassMethod=function(a,b,c){b.value=this.parseMethod(c),a.body.push(this.finishNode(b,"MethodDefinition"))},g.parseClassId=function(a,b){a.id=this.type===d.types.name?this.parseIdent():b?this.unexpected():null},g.parseClassSuper=function(a){a.superClass=this.eat(d.types._extends)?this.parseExprSubscripts():null},
// Parses module export declaration.
g.parseExport=function(a){
// export * from '...'
if(this.next(),this.eat(d.types.star))return this.expectContextual("from"),a.source=this.type===d.types.string?this.parseExprAtom():this.unexpected(),this.semicolon(),this.finishNode(a,"ExportAllDeclaration");if(this.eat(d.types._default)){
// export default ...
var b=this.parseMaybeAssign(),c=!0;return"FunctionExpression"!=b.type&&"ClassExpression"!=b.type||(c=!1,b.id&&(b.type="FunctionExpression"==b.type?"FunctionDeclaration":"ClassDeclaration")),a.declaration=b,c&&this.semicolon(),this.finishNode(a,"ExportDefaultDeclaration")}
// export var|const|let|function|class ...
if(this.shouldParseExportStatement())a.declaration=this.parseStatement(!0),a.specifiers=[],a.source=null;else{if(
// export { x, y as z } [from '...']
a.declaration=null,a.specifiers=this.parseExportSpecifiers(),this.eatContextual("from"))a.source=this.type===d.types.string?this.parseExprAtom():this.unexpected();else{
// check for keywords used as local names
for(var e=0;e<a.specifiers.length;e++)(this.keywords.test(a.specifiers[e].local.name)||this.reservedWords.test(a.specifiers[e].local.name))&&this.unexpected(a.specifiers[e].local.start);a.source=null}this.semicolon()}return this.finishNode(a,"ExportNamedDeclaration")},g.shouldParseExportStatement=function(){return this.type.keyword},
// Parses a comma-separated list of module exports.
g.parseExportSpecifiers=function(){var a=[],b=!0;for(
// export { x, y as z } [from '...']
this.expect(d.types.braceL);!this.eat(d.types.braceR);){if(b)b=!1;else if(this.expect(d.types.comma),this.afterTrailingComma(d.types.braceR))break;var c=this.startNode();c.local=this.parseIdent(this.type===d.types._default),c.exported=this.eatContextual("as")?this.parseIdent(!0):c.local,a.push(this.finishNode(c,"ExportSpecifier"))}return a},
// Parses import declaration.
g.parseImport=function(a){
// import '...'
return this.next(),this.type===d.types.string?(a.specifiers=j,a.source=this.parseExprAtom()):(a.specifiers=this.parseImportSpecifiers(),this.expectContextual("from"),a.source=this.type===d.types.string?this.parseExprAtom():this.unexpected()),this.semicolon(),this.finishNode(a,"ImportDeclaration")},
// Parses a comma-separated list of module imports.
g.parseImportSpecifiers=function(){var a=[],b=!0;if(this.type===d.types.name){
// import defaultObj, { x, y as z } from '...'
var c=this.startNode();if(c.local=this.parseIdent(),this.checkLVal(c.local,!0),a.push(this.finishNode(c,"ImportDefaultSpecifier")),!this.eat(d.types.comma))return a}if(this.type===d.types.star){var c=this.startNode();return this.next(),this.expectContextual("as"),c.local=this.parseIdent(),this.checkLVal(c.local,!0),a.push(this.finishNode(c,"ImportNamespaceSpecifier")),a}for(this.expect(d.types.braceL);!this.eat(d.types.braceR);){if(b)b=!1;else if(this.expect(d.types.comma),this.afterTrailingComma(d.types.braceR))break;var c=this.startNode();c.imported=this.parseIdent(!0),c.local=this.eatContextual("as")?this.parseIdent():c.imported,this.checkLVal(c.local,!0),a.push(this.finishNode(c,"ImportSpecifier"))}return a}},{"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(a,b,c){
// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design
"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}c.__esModule=!0;var e=a("./state"),f=a("./tokentype"),g=a("./whitespace"),h=function k(a,b,c,e){d(this,k),this.token=a,this.isExpr=!!b,this.preserveSpace=!!c,this.override=e};c.TokContext=h;var i={b_stat:new h("{",!1),b_expr:new h("{",!0),b_tmpl:new h("${",!0),p_stat:new h("(",!1),p_expr:new h("(",!0),q_tmpl:new h("`",!0,!0,function(a){return a.readTmplToken()}),f_expr:new h("function",!0)};c.types=i;var j=e.Parser.prototype;j.initialContext=function(){return[i.b_stat]},j.braceIsBlock=function(a){if(a===f.types.colon){var b=this.curContext();if(b===i.b_stat||b===i.b_expr)return!b.isExpr}return a===f.types._return?g.lineBreak.test(this.input.slice(this.lastTokEnd,this.start)):a===f.types._else||a===f.types.semi||a===f.types.eof||a===f.types.parenR?!0:a==f.types.braceL?this.curContext()===i.b_stat:!this.exprAllowed},j.updateContext=function(a){var b=void 0,c=this.type;c.keyword&&a==f.types.dot?this.exprAllowed=!1:(b=c.updateContext)?b.call(this,a):this.exprAllowed=c.beforeExpr},
// Token-specific context update code
f.types.parenR.updateContext=f.types.braceR.updateContext=function(){if(1==this.context.length)return void(this.exprAllowed=!0);var a=this.context.pop();a===i.b_stat&&this.curContext()===i.f_expr?(this.context.pop(),this.exprAllowed=!1):a===i.b_tmpl?this.exprAllowed=!0:this.exprAllowed=!a.isExpr},f.types.braceL.updateContext=function(a){this.context.push(this.braceIsBlock(a)?i.b_stat:i.b_expr),this.exprAllowed=!0},f.types.dollarBraceL.updateContext=function(){this.context.push(i.b_tmpl),this.exprAllowed=!0},f.types.parenL.updateContext=function(a){var b=a===f.types._if||a===f.types._for||a===f.types._with||a===f.types._while;this.context.push(b?i.p_stat:i.p_expr),this.exprAllowed=!0},f.types.incDec.updateContext=function(){},f.types._function.updateContext=function(){this.curContext()!==i.b_stat&&this.context.push(i.f_expr),this.exprAllowed=!1},f.types.backQuote.updateContext=function(){this.curContext()===i.q_tmpl?this.context.pop():this.context.push(i.q_tmpl),this.exprAllowed=!1}},{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(a,b,c){"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}
// Parse a regular expression. Some context-awareness is necessary,
// since a '/' inside a '[]' set does not end the expression.
function e(a,b,c,d){try{return new RegExp(a,b)}catch(e){if(void 0!==c)throw e instanceof SyntaxError&&d.raise(c,"Error parsing regular expression: "+e.message),e}}function f(a){
// UTF-16 Decoding
// UTF-16 Decoding
return 65535>=a?String.fromCharCode(a):(a-=65536,String.fromCharCode((a>>10)+55296,(1023&a)+56320))}c.__esModule=!0;var g=a("./identifier"),h=a("./tokentype"),i=a("./state"),j=a("./locutil"),k=a("./whitespace"),l=function p(a){d(this,p),this.type=a.type,this.value=a.value,this.start=a.start,this.end=a.end,a.options.locations&&(this.loc=new j.SourceLocation(a,a.startLoc,a.endLoc)),a.options.ranges&&(this.range=[a.start,a.end])};c.Token=l;var m=i.Parser.prototype,n="object"==typeof Packages&&"[object JavaPackage]"==Object.prototype.toString.call(Packages);
// Move to the next token
m.next=function(){this.options.onToken&&this.options.onToken(new l(this)),this.lastTokEnd=this.end,this.lastTokStart=this.start,this.lastTokEndLoc=this.endLoc,this.lastTokStartLoc=this.startLoc,this.nextToken()},m.getToken=function(){return this.next(),new l(this)},
// If we're in an ES6 environment, make parsers iterable
"undefined"!=typeof Symbol&&(m[Symbol.iterator]=function(){var a=this;return{next:function(){var b=a.getToken();return{done:b.type===h.types.eof,value:b}}}}),
// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).
m.setStrict=function(a){if(this.strict=a,this.type===h.types.num||this.type===h.types.string){if(this.pos=this.start,this.options.locations)for(;this.pos<this.lineStart;)this.lineStart=this.input.lastIndexOf("\n",this.lineStart-2)+1,--this.curLine;this.nextToken()}},m.curContext=function(){return this.context[this.context.length-1]},
// Read a single token, updating the parser object's token-related
// properties.
m.nextToken=function(){var a=this.curContext();return a&&a.preserveSpace||this.skipSpace(),this.start=this.pos,this.options.locations&&(this.startLoc=this.curPosition()),this.pos>=this.input.length?this.finishToken(h.types.eof):a.override?a.override(this):void this.readToken(this.fullCharCodeAtPos())},m.readToken=function(a){
// Identifier or keyword. '\uXXXX' sequences are allowed in
// identifiers, so '\' also dispatches to that.
// Identifier or keyword. '\uXXXX' sequences are allowed in
// identifiers, so '\' also dispatches to that.
return g.isIdentifierStart(a,this.options.ecmaVersion>=6)||92===a?this.readWord():this.getTokenFromCode(a)},m.fullCharCodeAtPos=function(){var a=this.input.charCodeAt(this.pos);if(55295>=a||a>=57344)return a;var b=this.input.charCodeAt(this.pos+1);return(a<<10)+b-56613888},m.skipBlockComment=function(){var a=this.options.onComment&&this.curPosition(),b=this.pos,c=this.input.indexOf("*/",this.pos+=2);if(-1===c&&this.raise(this.pos-2,"Unterminated comment"),this.pos=c+2,this.options.locations){k.lineBreakG.lastIndex=b;for(var d=void 0;(d=k.lineBreakG.exec(this.input))&&d.index<this.pos;)++this.curLine,this.lineStart=d.index+d[0].length}this.options.onComment&&this.options.onComment(!0,this.input.slice(b+2,c),b,this.pos,a,this.curPosition())},m.skipLineComment=function(a){for(var b=this.pos,c=this.options.onComment&&this.curPosition(),d=this.input.charCodeAt(this.pos+=a);this.pos<this.input.length&&10!==d&&13!==d&&8232!==d&&8233!==d;)++this.pos,d=this.input.charCodeAt(this.pos);this.options.onComment&&this.options.onComment(!1,this.input.slice(b+a,this.pos),b,this.pos,c,this.curPosition())},
// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.
m.skipSpace=function(){a:for(;this.pos<this.input.length;){var a=this.input.charCodeAt(this.pos);switch(a){case 32:case 160:
// ' '
++this.pos;break;case 13:10===this.input.charCodeAt(this.pos+1)&&++this.pos;case 10:case 8232:case 8233:++this.pos,this.options.locations&&(++this.curLine,this.lineStart=this.pos);break;case 47:
// '/'
switch(this.input.charCodeAt(this.pos+1)){case 42:
// '*'
this.skipBlockComment();break;case 47:this.skipLineComment(2);break;default:break a}break;default:if(!(a>8&&14>a||a>=5760&&k.nonASCIIwhitespace.test(String.fromCharCode(a))))break a;++this.pos}}},
// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.
m.finishToken=function(a,b){this.end=this.pos,this.options.locations&&(this.endLoc=this.curPosition());var c=this.type;this.type=a,this.value=b,this.updateContext(c)},
// ### Token reading
// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
m.readToken_dot=function(){var a=this.input.charCodeAt(this.pos+1);if(a>=48&&57>=a)return this.readNumber(!0);var b=this.input.charCodeAt(this.pos+2);
// 46 = dot '.'
return this.options.ecmaVersion>=6&&46===a&&46===b?(this.pos+=3,this.finishToken(h.types.ellipsis)):(++this.pos,this.finishToken(h.types.dot))},m.readToken_slash=function(){
// '/'
var a=this.input.charCodeAt(this.pos+1);return this.exprAllowed?(++this.pos,this.readRegexp()):61===a?this.finishOp(h.types.assign,2):this.finishOp(h.types.slash,1)},m.readToken_mult_modulo=function(a){
// '%*'
var b=this.input.charCodeAt(this.pos+1);return 61===b?this.finishOp(h.types.assign,2):this.finishOp(42===a?h.types.star:h.types.modulo,1)},m.readToken_pipe_amp=function(a){
// '|&'
var b=this.input.charCodeAt(this.pos+1);return b===a?this.finishOp(124===a?h.types.logicalOR:h.types.logicalAND,2):61===b?this.finishOp(h.types.assign,2):this.finishOp(124===a?h.types.bitwiseOR:h.types.bitwiseAND,1)},m.readToken_caret=function(){
// '^'
var a=this.input.charCodeAt(this.pos+1);return 61===a?this.finishOp(h.types.assign,2):this.finishOp(h.types.bitwiseXOR,1)},m.readToken_plus_min=function(a){
// '+-'
var b=this.input.charCodeAt(this.pos+1);
// A `-->` line comment
return b===a?45==b&&62==this.input.charCodeAt(this.pos+2)&&k.lineBreak.test(this.input.slice(this.lastTokEnd,this.pos))?(this.skipLineComment(3),this.skipSpace(),this.nextToken()):this.finishOp(h.types.incDec,2):61===b?this.finishOp(h.types.assign,2):this.finishOp(h.types.plusMin,1)},m.readToken_lt_gt=function(a){
// '<>'
var b=this.input.charCodeAt(this.pos+1),c=1;
// `<!--`, an XML-style comment that should be interpreted as a line comment
return b===a?(c=62===a&&62===this.input.charCodeAt(this.pos+2)?3:2,61===this.input.charCodeAt(this.pos+c)?this.finishOp(h.types.assign,c+1):this.finishOp(h.types.bitShift,c)):33==b&&60==a&&45==this.input.charCodeAt(this.pos+2)&&45==this.input.charCodeAt(this.pos+3)?(this.inModule&&this.unexpected(),this.skipLineComment(4),this.skipSpace(),this.nextToken()):(61===b&&(c=61===this.input.charCodeAt(this.pos+2)?3:2),this.finishOp(h.types.relational,c))},m.readToken_eq_excl=function(a){
// '=!'
var b=this.input.charCodeAt(this.pos+1);
// '=>'
return 61===b?this.finishOp(h.types.equality,61===this.input.charCodeAt(this.pos+2)?3:2):61===a&&62===b&&this.options.ecmaVersion>=6?(this.pos+=2,this.finishToken(h.types.arrow)):this.finishOp(61===a?h.types.eq:h.types.prefix,1)},m.getTokenFromCode=function(a){switch(a){
// The interpretation of a dot depends on whether it is followed
// by a digit or another two dots.
case 46:
// '.'
return this.readToken_dot();
// Punctuation tokens.
case 40:return++this.pos,this.finishToken(h.types.parenL);case 41:return++this.pos,this.finishToken(h.types.parenR);case 59:return++this.pos,this.finishToken(h.types.semi);case 44:return++this.pos,this.finishToken(h.types.comma);case 91:return++this.pos,this.finishToken(h.types.bracketL);case 93:return++this.pos,this.finishToken(h.types.bracketR);case 123:return++this.pos,this.finishToken(h.types.braceL);case 125:return++this.pos,this.finishToken(h.types.braceR);case 58:return++this.pos,this.finishToken(h.types.colon);case 63:return++this.pos,this.finishToken(h.types.question);case 96:
// '`'
if(this.options.ecmaVersion<6)break;return++this.pos,this.finishToken(h.types.backQuote);case 48:
// '0'
var b=this.input.charCodeAt(this.pos+1);if(120===b||88===b)return this.readRadixNumber(16);// '0x', '0X' - hex number
if(this.options.ecmaVersion>=6){if(111===b||79===b)return this.readRadixNumber(8);// '0o', '0O' - octal number
if(98===b||66===b)return this.readRadixNumber(2)}
// Anything else beginning with a digit is an integer, octal
// number, or float.
case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
// 1-9
return this.readNumber(!1);
// Quotes produce strings.
case 34:case 39:
// '"', "'"
return this.readString(a);
// Operators are parsed inline in tiny state machines. '=' (61) is
// often referred to. `finishOp` simply skips the amount of
// characters it is given as second argument, and returns a token
// of the type given by its first argument.
case 47:
// '/'
return this.readToken_slash();case 37:case 42:
// '%*'
return this.readToken_mult_modulo(a);case 124:case 38:
// '|&'
return this.readToken_pipe_amp(a);case 94:
// '^'
return this.readToken_caret();case 43:case 45:
// '+-'
return this.readToken_plus_min(a);case 60:case 62:
// '<>'
return this.readToken_lt_gt(a);case 61:case 33:
// '=!'
return this.readToken_eq_excl(a);case 126:
// '~'
return this.finishOp(h.types.prefix,1)}this.raise(this.pos,"Unexpected character '"+f(a)+"'")},m.finishOp=function(a,b){var c=this.input.slice(this.pos,this.pos+b);return this.pos+=b,this.finishToken(a,c)};var o=!!e("","u");m.readRegexp=function(){for(var a=this,b=void 0,c=void 0,d=this.pos;;){this.pos>=this.input.length&&this.raise(d,"Unterminated regular expression");var f=this.input.charAt(this.pos);if(k.lineBreak.test(f)&&this.raise(d,"Unterminated regular expression"),b)b=!1;else{if("["===f)c=!0;else if("]"===f&&c)c=!1;else if("/"===f&&!c)break;b="\\"===f}++this.pos}var g=this.input.slice(d,this.pos);++this.pos;
// Need to use `readWord1` because '\uXXXX' sequences are allowed
// here (don't ask).
var i=this.readWord1(),j=g;if(i){var l=/^[gmsiy]*$/;this.options.ecmaVersion>=6&&(l=/^[gmsiyu]*$/),l.test(i)||this.raise(d,"Invalid regular expression flag"),i.indexOf("u")>=0&&!o&&(j=j.replace(/\\u\{([0-9a-fA-F]+)\}/g,function(b,c,e){return c=Number("0x"+c),c>1114111&&a.raise(d+e+3,"Code point out of bounds"),"x"}),j=j.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,"x"))}
// Detect invalid regular expressions.
var m=null;
// Rhino's regular expression parser is flaky and throws uncatchable exceptions,
// so don't do detection if we are running under Rhino
// Get a regular expression object for this pattern-flag pair, or `null` in
// case the current environment doesn't support the flags it uses.
return n||(e(j,void 0,d,this),m=e(g,i)),this.finishToken(h.types.regexp,{pattern:g,flags:i,value:m})},
// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.
m.readInt=function(a,b){for(var c=this.pos,d=0,e=0,f=null==b?1/0:b;f>e;++e){var g=this.input.charCodeAt(this.pos),h=void 0;if(h=g>=97?g-97+10:g>=65?g-65+10:g>=48&&57>=g?g-48:1/0,h>=a)break;++this.pos,d=d*a+h}return this.pos===c||null!=b&&this.pos-c!==b?null:d},m.readRadixNumber=function(a){this.pos+=2;// 0x
var b=this.readInt(a);return null==b&&this.raise(this.start+2,"Expected number in radix "+a),g.isIdentifierStart(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number"),this.finishToken(h.types.num,b)},
// Read an integer, octal integer, or floating-point number.
m.readNumber=function(a){var b=this.pos,c=!1,d=48===this.input.charCodeAt(this.pos);a||null!==this.readInt(10)||this.raise(b,"Invalid number");var e=this.input.charCodeAt(this.pos);46===e&&(
// '.'
++this.pos,this.readInt(10),c=!0,e=this.input.charCodeAt(this.pos)),69!==e&&101!==e||(e=this.input.charCodeAt(++this.pos),43!==e&&45!==e||++this.pos,null===this.readInt(10)&&this.raise(b,"Invalid number"),c=!0),g.isIdentifierStart(this.fullCharCodeAtPos())&&this.raise(this.pos,"Identifier directly after number");var f=this.input.slice(b,this.pos),i=void 0;return c?i=parseFloat(f):d&&1!==f.length?/[89]/.test(f)||this.strict?this.raise(b,"Invalid number"):i=parseInt(f,8):i=parseInt(f,10),this.finishToken(h.types.num,i)},
// Read a string value, interpreting backslash-escapes.
m.readCodePoint=function(){var a=this.input.charCodeAt(this.pos),b=void 0;if(123===a){this.options.ecmaVersion<6&&this.unexpected();var c=++this.pos;b=this.readHexChar(this.input.indexOf("}",this.pos)-this.pos),++this.pos,b>1114111&&this.raise(c,"Code point out of bounds")}else b=this.readHexChar(4);return b},m.readString=function(a){for(var b="",c=++this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated string constant");var d=this.input.charCodeAt(this.pos);if(d===a)break;92===d?(b+=this.input.slice(c,this.pos),b+=this.readEscapedChar(!1),c=this.pos):(k.isNewLine(d)&&this.raise(this.start,"Unterminated string constant"),++this.pos)}return b+=this.input.slice(c,this.pos++),this.finishToken(h.types.string,b)},
// Reads template string tokens.
m.readTmplToken=function(){for(var a="",b=this.pos;;){this.pos>=this.input.length&&this.raise(this.start,"Unterminated template");var c=this.input.charCodeAt(this.pos);if(96===c||36===c&&123===this.input.charCodeAt(this.pos+1))
// '`', '${'
// '`', '${'
return this.pos===this.start&&this.type===h.types.template?36===c?(this.pos+=2,this.finishToken(h.types.dollarBraceL)):(++this.pos,this.finishToken(h.types.backQuote)):(a+=this.input.slice(b,this.pos),this.finishToken(h.types.template,a));if(92===c)a+=this.input.slice(b,this.pos),a+=this.readEscapedChar(!0),b=this.pos;else if(k.isNewLine(c)){switch(a+=this.input.slice(b,this.pos),++this.pos,c){case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;case 10:a+="\n";break;default:a+=String.fromCharCode(c)}this.options.locations&&(++this.curLine,this.lineStart=this.pos),b=this.pos}else++this.pos}},
// Used to read escaped characters
m.readEscapedChar=function(a){var b=this.input.charCodeAt(++this.pos);switch(++this.pos,b){case 110:return"\n";// 'n' -> '\n'
case 114:return"\r";// 'r' -> '\r'
case 120:return String.fromCharCode(this.readHexChar(2));// 'x'
case 117:return f(this.readCodePoint());// 'u'
case 116:return"	";// 't' -> '\t'
case 98:return"\b";// 'b' -> '\b'
case 118:return"\x0B";// 'v' -> '\u000b'
case 102:return"\f";// 'f' -> '\f'
case 13:10===this.input.charCodeAt(this.pos)&&++this.pos;// '\r\n'
case 10:
// ' \n'
return this.options.locations&&(this.lineStart=this.pos,++this.curLine),"";default:if(b>=48&&55>=b){var c=this.input.substr(this.pos-1,3).match(/^[0-7]+/)[0],d=parseInt(c,8);return d>255&&(c=c.slice(0,-1),d=parseInt(c,8)),d>0&&(this.strict||a)&&this.raise(this.pos-2,"Octal literal in strict mode"),this.pos+=c.length-1,String.fromCharCode(d)}return String.fromCharCode(b)}},
// Used to read character escape sequences ('\x', '\u', '\U').
m.readHexChar=function(a){var b=this.pos,c=this.readInt(16,a);return null===c&&this.raise(b,"Bad character escape sequence"),c},
// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.
m.readWord1=function(){this.containsEsc=!1;for(var a="",b=!0,c=this.pos,d=this.options.ecmaVersion>=6;this.pos<this.input.length;){var e=this.fullCharCodeAtPos();if(g.isIdentifierChar(e,d))this.pos+=65535>=e?1:2;else{if(92!==e)break;
// "\"
this.containsEsc=!0,a+=this.input.slice(c,this.pos);var h=this.pos;117!=this.input.charCodeAt(++this.pos)&&// "u"
this.raise(this.pos,"Expecting Unicode escape sequence \\uXXXX"),++this.pos;var i=this.readCodePoint();(b?g.isIdentifierStart:g.isIdentifierChar)(i,d)||this.raise(h,"Invalid Unicode escape"),a+=f(i),c=this.pos}b=!1}return a+this.input.slice(c,this.pos)},
// Read an identifier or keyword token. Will check for reserved
// words when necessary.
m.readWord=function(){var a=this.readWord1(),b=h.types.name;return(this.options.ecmaVersion>=6||!this.containsEsc)&&this.keywords.test(a)&&(b=h.keywords[a]),this.finishToken(b,a)}},{"./identifier":2,"./locutil":5,"./state":10,"./tokentype":14,"./whitespace":16}],14:[function(a,b,c){
// ## Token types
// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.
// All token type variables start with an underscore, to make them
// easy to recognize.
// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.
"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(a,b){return new g(a,{beforeExpr:!0,binop:b})}
// Succinct definitions of keyword token types
function f(a){var b=arguments.length<=1||void 0===arguments[1]?{}:arguments[1];b.keyword=a,k[a]=j["_"+a]=new g(a,b)}c.__esModule=!0;var g=function l(a){var b=arguments.length<=1||void 0===arguments[1]?{}:arguments[1];d(this,l),this.label=a,this.keyword=b.keyword,this.beforeExpr=!!b.beforeExpr,this.startsExpr=!!b.startsExpr,this.isLoop=!!b.isLoop,this.isAssign=!!b.isAssign,this.prefix=!!b.prefix,this.postfix=!!b.postfix,this.binop=b.binop||null,this.updateContext=null};c.TokenType=g;var h={beforeExpr:!0},i={startsExpr:!0},j={num:new g("num",i),regexp:new g("regexp",i),string:new g("string",i),name:new g("name",i),eof:new g("eof"),
// Punctuation token types.
bracketL:new g("[",{beforeExpr:!0,startsExpr:!0}),bracketR:new g("]"),braceL:new g("{",{beforeExpr:!0,startsExpr:!0}),braceR:new g("}"),parenL:new g("(",{beforeExpr:!0,startsExpr:!0}),parenR:new g(")"),comma:new g(",",h),semi:new g(";",h),colon:new g(":",h),dot:new g("."),question:new g("?",h),arrow:new g("=>",h),template:new g("template"),ellipsis:new g("...",h),backQuote:new g("`",i),dollarBraceL:new g("${",{beforeExpr:!0,startsExpr:!0}),
// Operators. These carry several kinds of properties to help the
// parser use them properly (the presence of these properties is
// what categorizes them as operators).
//
// `binop`, when present, specifies that this operator is a binary
// operator, and will refer to its precedence.
//
// `prefix` and `postfix` mark the operator as a prefix or postfix
// unary operator.
//
// `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
// binary operators with a very low precedence, that should result
// in AssignmentExpression nodes.
eq:new g("=",{beforeExpr:!0,isAssign:!0}),assign:new g("_=",{beforeExpr:!0,isAssign:!0}),incDec:new g("++/--",{prefix:!0,postfix:!0,startsExpr:!0}),prefix:new g("prefix",{beforeExpr:!0,prefix:!0,startsExpr:!0}),logicalOR:e("||",1),logicalAND:e("&&",2),bitwiseOR:e("|",3),bitwiseXOR:e("^",4),bitwiseAND:e("&",5),equality:e("==/!=",6),relational:e("</>",7),bitShift:e("<</>>",8),plusMin:new g("+/-",{beforeExpr:!0,binop:9,prefix:!0,startsExpr:!0}),modulo:e("%",10),star:e("*",10),slash:e("/",10)};c.types=j;
// Map keyword names to token types.
var k={};c.keywords=k,f("break"),f("case",h),f("catch"),f("continue"),f("debugger"),f("default",h),f("do",{isLoop:!0,beforeExpr:!0}),f("else",h),f("finally"),f("for",{isLoop:!0}),f("function",i),f("if"),f("return",h),f("switch"),f("throw",h),f("try"),f("var"),f("let"),f("const"),f("while",{isLoop:!0}),f("with"),f("new",{beforeExpr:!0,startsExpr:!0}),f("this",i),f("super",i),f("class"),f("extends",h),f("export"),f("import"),f("yield",{beforeExpr:!0,startsExpr:!0}),f("null",i),f("true",i),f("false",i),f("in",{beforeExpr:!0,binop:7}),f("instanceof",{beforeExpr:!0,binop:7}),f("typeof",{beforeExpr:!0,prefix:!0,startsExpr:!0}),f("void",{beforeExpr:!0,prefix:!0,startsExpr:!0}),f("delete",{beforeExpr:!0,prefix:!0,startsExpr:!0})},{}],15:[function(a,b,c){"use strict";function d(a){return"[object Array]"===Object.prototype.toString.call(a)}
// Checks if an object has a property.
function e(a,b){return Object.prototype.hasOwnProperty.call(a,b)}c.__esModule=!0,c.isArray=d,c.has=e},{}],16:[function(a,b,c){
// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.
"use strict";function d(a){return 10===a||13===a||8232===a||8233==a}c.__esModule=!0,c.isNewLine=d;var e=/\r\n?|\n|\u2028|\u2029/;c.lineBreak=e;var f=new RegExp(e.source,"g");c.lineBreakG=f;var g=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;c.nonASCIIwhitespace=g},{}]},{},[3])(3)})}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],50:[function(a,b,c){(function(d){!function(a){if("object"==typeof c&&"undefined"!=typeof b)b.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof d?d:"undefined"!=typeof self?self:this,(e.acorn||(e.acorn={})).walk=a()}}(function(){return function b(c,d,e){function f(h,i){if(!d[h]){if(!c[h]){var j="function"==typeof a&&a;if(!i&&j)return j(h,!0);if(g)return g(h,!0);var k=new Error("Cannot find module '"+h+"'");throw k.code="MODULE_NOT_FOUND",k}var l=d[h]={exports:{}};c[h][0].call(l.exports,function(a){var b=c[h][1][a];return f(b?b:a)},l,l.exports,b,c,d,e)}return d[h].exports}for(var g="function"==typeof a&&a,h=0;h<e.length;h++)f(e[h]);return f}({1:[function(a,b,c){
// AST walker module for Mozilla Parser API compatible trees
// A simple walk is one where you simply specify callbacks to be
// called on specific nodes. The last two arguments are optional. A
// simple use would be
//
//     walk.simple(myTree, {
//         Expression: function(node) { ... }
//     });
//
// to do something with all expressions. All Parser API node types
// can be used to identify node types, as well as Expression,
// Statement, and ScopeBody, which denote categories of nodes.
//
// The base argument can be used to pass a custom (recursive)
// walker, and state can be used to give this walked an initial
// state.
"use strict";function d(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function e(a,b,d,e,f){d||(d=c.base),function g(a,c,e){var f=e||a.type,h=b[f];d[f](a,c,g),h&&h(a,c)}(a,e,f)}
// An ancestor walk builds up an array of ancestor nodes (including
// the current node) and passes them to the callback as the state parameter.
function f(a,b,d,e){d||(d=c.base),e||(e=[]),function f(a,c,e){var g=e||a.type,h=b[g];a!=c[c.length-1]&&(c=c.slice(),c.push(a)),d[g](a,c,f),h&&h(a,c)}(a,e)}
// A recursive walk is one where your functions override the default
// walkers. They can modify and replace the state parameter that's
// threaded through the walk, and can opt how and whether to walk
// their child nodes (by calling their third argument on these
// nodes).
function g(a,b,d,e,f){var g=d?c.make(d,e):e;!function h(a,b,c){g[c||a.type](a,b,h)}(a,b,f)}function h(a){return"string"==typeof a?function(b){return b==a}:a?a:function(){return!0}}function i(a,b,d,e,f,g){e=h(e),f||(f=c.base);try{!function j(a,c,g){var h=g||a.type;if((null==b||a.start<=b)&&(null==d||a.end>=d)&&f[h](a,c,j),(null==b||a.start==b)&&(null==d||a.end==d)&&e(h,a))throw new p(a,c)}(a,g)}catch(i){if(i instanceof p)return i;throw i}}
// Find the innermost node of a given type that contains the given
// position. Interface similar to findNodeAt.
function j(a,b,d,e,f){d=h(d),e||(e=c.base);try{!function i(a,c,f){var g=f||a.type;if(!(a.start>b||a.end<b)&&(e[g](a,c,i),d(g,a)))throw new p(a,c)}(a,f)}catch(g){if(g instanceof p)return g;throw g}}
// Find the outermost matching node after a given position.
function k(a,b,d,e,f){d=h(d),e||(e=c.base);try{!function i(a,c,f){if(!(a.end<b)){var g=f||a.type;if(a.start>=b&&d(g,a))throw new p(a,c);e[g](a,c,i)}}(a,f)}catch(g){if(g instanceof p)return g;throw g}}
// Find the outermost matching node before a given position.
function l(a,b,d,e,f){d=h(d),e||(e=c.base);var g=void 0;return function i(a,c,f){if(!(a.start>b)){var h=f||a.type;a.end<=b&&(!g||g.node.end<a.end)&&d(h,a)&&(g=new p(a,c)),e[h](a,c,i)}}(a,f),g}
// Used to create a custom walker. Will fill in all missing node
// type properties with the defaults.
function m(a,b){b||(b=c.base);var d={};for(var e in b)d[e]=b[e];for(var e in a)d[e]=a[e];return d}function n(a,b,c){c(a,b)}function o(a,b,c){}c.__esModule=!0,c.simple=e,c.ancestor=f,c.recursive=g,c.findNodeAt=i,c.findNodeAround=j,c.findNodeAfter=k,c.findNodeBefore=l,c.make=m;var p=function r(a,b){d(this,r),this.node=a,this.state=b},q={};c.base=q,q.Program=q.BlockStatement=function(a,b,c){for(var d=0;d<a.body.length;++d)c(a.body[d],b,"Statement")},q.Statement=n,q.EmptyStatement=o,q.ExpressionStatement=q.ParenthesizedExpression=function(a,b,c){return c(a.expression,b,"Expression")},q.IfStatement=function(a,b,c){c(a.test,b,"Expression"),c(a.consequent,b,"Statement"),a.alternate&&c(a.alternate,b,"Statement")},q.LabeledStatement=function(a,b,c){return c(a.body,b,"Statement")},q.BreakStatement=q.ContinueStatement=o,q.WithStatement=function(a,b,c){c(a.object,b,"Expression"),c(a.body,b,"Statement")},q.SwitchStatement=function(a,b,c){c(a.discriminant,b,"Expression");for(var d=0;d<a.cases.length;++d){var e=a.cases[d];e.test&&c(e.test,b,"Expression");for(var f=0;f<e.consequent.length;++f)c(e.consequent[f],b,"Statement")}},q.ReturnStatement=q.YieldExpression=function(a,b,c){a.argument&&c(a.argument,b,"Expression")},q.ThrowStatement=q.SpreadElement=function(a,b,c){return c(a.argument,b,"Expression")},q.TryStatement=function(a,b,c){c(a.block,b,"Statement"),a.handler&&(c(a.handler.param,b,"Pattern"),c(a.handler.body,b,"ScopeBody")),a.finalizer&&c(a.finalizer,b,"Statement")},q.WhileStatement=q.DoWhileStatement=function(a,b,c){c(a.test,b,"Expression"),c(a.body,b,"Statement")},q.ForStatement=function(a,b,c){a.init&&c(a.init,b,"ForInit"),a.test&&c(a.test,b,"Expression"),a.update&&c(a.update,b,"Expression"),c(a.body,b,"Statement")},q.ForInStatement=q.ForOfStatement=function(a,b,c){c(a.left,b,"ForInit"),c(a.right,b,"Expression"),c(a.body,b,"Statement")},q.ForInit=function(a,b,c){"VariableDeclaration"==a.type?c(a,b):c(a,b,"Expression")},q.DebuggerStatement=o,q.FunctionDeclaration=function(a,b,c){return c(a,b,"Function")},q.VariableDeclaration=function(a,b,c){for(var d=0;d<a.declarations.length;++d)c(a.declarations[d],b)},q.VariableDeclarator=function(a,b,c){c(a.id,b,"Pattern"),a.init&&c(a.init,b,"Expression")},q.Function=function(a,b,c){a.id&&c(a.id,b,"Pattern");for(var d=0;d<a.params.length;d++)c(a.params[d],b,"Pattern");c(a.body,b,a.expression?"ScopeExpression":"ScopeBody")},
// FIXME drop these node types in next major version
// (They are awkward, and in ES6 every block can be a scope.)
q.ScopeBody=function(a,b,c){return c(a,b,"Statement")},q.ScopeExpression=function(a,b,c){return c(a,b,"Expression")},q.Pattern=function(a,b,c){"Identifier"==a.type?c(a,b,"VariablePattern"):"MemberExpression"==a.type?c(a,b,"MemberPattern"):c(a,b)},q.VariablePattern=o,q.MemberPattern=n,q.RestElement=function(a,b,c){return c(a.argument,b,"Pattern")},q.ArrayPattern=function(a,b,c){for(var d=0;d<a.elements.length;++d){var e=a.elements[d];e&&c(e,b,"Pattern")}},q.ObjectPattern=function(a,b,c){for(var d=0;d<a.properties.length;++d)c(a.properties[d].value,b,"Pattern")},q.Expression=n,q.ThisExpression=q.Super=q.MetaProperty=o,q.ArrayExpression=function(a,b,c){for(var d=0;d<a.elements.length;++d){var e=a.elements[d];e&&c(e,b,"Expression")}},q.ObjectExpression=function(a,b,c){for(var d=0;d<a.properties.length;++d)c(a.properties[d],b)},q.FunctionExpression=q.ArrowFunctionExpression=q.FunctionDeclaration,q.SequenceExpression=q.TemplateLiteral=function(a,b,c){for(var d=0;d<a.expressions.length;++d)c(a.expressions[d],b,"Expression")},q.UnaryExpression=q.UpdateExpression=function(a,b,c){c(a.argument,b,"Expression")},q.BinaryExpression=q.LogicalExpression=function(a,b,c){c(a.left,b,"Expression"),c(a.right,b,"Expression")},q.AssignmentExpression=q.AssignmentPattern=function(a,b,c){c(a.left,b,"Pattern"),c(a.right,b,"Expression")},q.ConditionalExpression=function(a,b,c){c(a.test,b,"Expression"),c(a.consequent,b,"Expression"),c(a.alternate,b,"Expression")},q.NewExpression=q.CallExpression=function(a,b,c){if(c(a.callee,b,"Expression"),a.arguments)for(var d=0;d<a.arguments.length;++d)c(a.arguments[d],b,"Expression")},q.MemberExpression=function(a,b,c){c(a.object,b,"Expression"),a.computed&&c(a.property,b,"Expression")},q.ExportNamedDeclaration=q.ExportDefaultDeclaration=function(a,b,c){a.declaration&&c(a.declaration,b,"ExportNamedDeclaration"==a.type||a.declaration.id?"Statement":"Expression"),a.source&&c(a.source,b,"Expression")},q.ExportAllDeclaration=function(a,b,c){c(a.source,b,"Expression")},q.ImportDeclaration=function(a,b,c){for(var d=0;d<a.specifiers.length;d++)c(a.specifiers[d],b);c(a.source,b,"Expression")},q.ImportSpecifier=q.ImportDefaultSpecifier=q.ImportNamespaceSpecifier=q.Identifier=q.Literal=o,q.TaggedTemplateExpression=function(a,b,c){c(a.tag,b,"Expression"),c(a.quasi,b)},q.ClassDeclaration=q.ClassExpression=function(a,b,c){return c(a,b,"Class")},q.Class=function(a,b,c){a.id&&c(a.id,b,"Pattern"),a.superClass&&c(a.superClass,b,"Expression");for(var d=0;d<a.body.body.length;d++)c(a.body.body[d],b)},q.MethodDefinition=q.Property=function(a,b,c){a.computed&&c(a.key,b,"Expression"),c(a.value,b,"Expression")},q.ComprehensionExpression=function(a,b,c){for(var d=0;d<a.blocks.length;d++)c(a.blocks[d].right,b,"Expression");c(a.body,b,"Expression")}},{}]},{},[1])(1)})}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],51:[function(a,b,c){function d(a){return a&&k.ArrayExpression===a.type}function e(a,b){return k.Identifier===a.type&&b===a.name}function f(a){return 1===a.length&&k.Literal===a[0].type?a[0].value:void 0}function g(a){var b,c,e;if(
// Handle define([], function() {}) format
d(a[0])?b=a[0].elements:d(a[1])&&(b=a[1].elements),b)for(c=0,e=b.length;e>c;c++)b[c]=b[c].value;return b}/**
 * Method to pull dependencies from a JavaScript source string.
 *
 * @param {string} source - Source to parse
 * @param {object} options - Options passed to acorn
 *
 * @returns {object:{array: dependencies}} - Object with dependencies
 */
function h(a,b){return h.walk(i.parse(a,b))}var i=a("acorn"),j=a("acorn/dist/walk"),k={_define:"define",_require:"require",Identifier:"Identifier",Literal:"Literal",ArrayExpression:"ArrayExpression"};/**
 * Method to pull dependencies from an AST.
 *
 * @param {object} ast - AST to traverse in order to find all dependencies.
 *
 * @returns {object:{array: dependencies}} - Object with dependencies
 */
h.walk=function(a){function b(a){if(e(a.callee,k._require)){var b=f(a.arguments);b&&c.dependencies.push(b)}else if(e(a.callee,k._define)){var d=g(a.arguments);d&&d.length&&(c.dependencies=c.dependencies.concat(d))}}var c={dependencies:[]};return j.simple(a,{CallExpression:b}),c},b.exports=h},{acorn:49,"acorn/dist/walk":50}],52:[function(a,b,c){/**
 * Method to process dependencies.
 *
 * @param {{source: source}} data - Object with `source` property to be
 *  processed for dependencies
 */
function d(a,b){return e(a,b)}function e(a,b){return f(a,g(a.source,b).dependencies)}function f(a,b){return b.length?{deps:a.deps.concat(b)}:void 0}var g=a("pulling-deps");/**
 * Method to configure a dependencies processor.
 *
 * @param {object} options - Configuration settings for processing dependencies
 *  This module uses [acorn]{@link http://marijnhaverbeke.nl/acorn/}, which is
 *  what the options are actually passed to.
 *
 * @returns {function} Delegate to be called with an object with a `source`
 *  property to pull the dependencies from.
 */
d.config=function(a){return function(b){return e(b,a)}},b.exports=d},{"pulling-deps":51}],53:[function(a,b,c){(function(a){/**
 * Checks is the input is a Buffer
 */
function c(a){return n(a)===o}/**
 * Check if input is undefined
 *
 * @param {*} item - Item to be tested for undefined
 * @returns {boolean}
 */
function d(a){return void 0===a}/**
 * Check if input is null
 *
 * @param {*} item - Item to be tested for null
 * @returns {boolean}
 */
function e(a){return null===a}/**
 * Check if input is a regulat expression
 *
 * @param {*} item - Item to check for regular expression
 * @returns {boolean}
 */
function f(a){return!!a&&n(a)===p}/**
 * Check if input is a function
 *
 * @param {*} item - Item to be tested for function
 * @returns {boolean}
 */
function g(a){return"function"==typeof a}/**
 * Check if input is a string
 *
 * @param {*} item - Item to check for string
 * @returns {boolean}
 */
function h(a){return"string"==typeof a}/**
 * Check if input is an object. Objects are:
 *  - literal object, object instances, arrays, null
 *
 * @param {*} item - Item to check for object
 * @returns {boolean}
 */
function i(a){return"object"==typeof a}/**
 * Check if input is a Date
 *
 * @param {*} item - Item to be tested for Date
 * @returns {boolean}
 */
function j(a){return n(a)===q}/**
 * Check if item is an object literal - plain object.
 *
 * @param {*} item - Item to check for object literal
 * @returns {boolean}
 */
function k(a){return n(a)===s}/**
 * Check if input is an error
 *
 * @param {*} item - Item to check for error
 * @returns {boolean}
 */
function l(a){return n(a)===t||a instanceof Error}/**
 * Extract the type name. This uses Object.prototype.toString
 * to get the type name.
 *
 * @param {*} item - Item to get the type for
 * @returns {string} type of the object
 */
function m(a){return e(a)?"null":d(a)?"undefined":/\[.+ ([^\]]+)/.exec(n(a))[1].toLowerCase()}var n=Function.prototype.apply.bind(Object.prototype.toString),o="undefined"!=typeof a?n(a):"[object Uint8Array]",p=n(/test/),q=n(new Date),r=n([]),s=n({}),t=n(new Error),u=function(){return Array.isArray?Array.isArray:function(a){return n(a)===r}}();b.exports={isNull:e,isUndefined:d,isRegex:f,isArray:u,isBuffer:c,isError:l,isString:h,isObject:i,isPlainObject:k,isFunction:g,isDate:j,typeName:m,toString:n}}).call(this,a("buffer").Buffer)},{buffer:54}],54:[function(a,b,c){(function(b){/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */
"use strict";function d(){try{var a=new Uint8Array(1);// typed array instances can be augmented
// chrome 9-10 lack `subarray`
return a.foo=function(){return 42},42===a.foo()&&"function"==typeof a.subarray&&0===a.subarray(1,1).byteLength}catch(b){return!1}}function e(){return g.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function f(a,b){if(e()<b)throw new RangeError("Invalid typed array length");
// Return an augmented `Uint8Array` instance, for best performance
// Fallback: Return an object instance of the Buffer class
return g.TYPED_ARRAY_SUPPORT?(a=new Uint8Array(b),a.__proto__=g.prototype):(null===a&&(a=new g(b)),a.length=b),a}/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */
function g(a,b,c){if(!(g.TYPED_ARRAY_SUPPORT||this instanceof g))return new g(a,b,c);
// Common case.
if("number"==typeof a){if("string"==typeof b)throw new Error("If encoding is specified then the first argument must be a string");return k(this,a)}return h(this,a,b,c)}function h(a,b,c,d){if("number"==typeof b)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&b instanceof ArrayBuffer?n(a,b,c,d):"string"==typeof b?l(a,b,c):o(a,b)}function i(a){if("number"!=typeof a)throw new TypeError('"size" argument must be a number')}function j(a,b,c,d){return i(b),0>=b?f(a,b):void 0!==c?"string"==typeof d?f(a,b).fill(c,d):f(a,b).fill(c):f(a,b)}function k(a,b){if(i(b),a=f(a,0>b?0:0|p(b)),!g.TYPED_ARRAY_SUPPORT)for(var c=0;b>c;c++)a[c]=0;return a}function l(a,b,c){if("string"==typeof c&&""!==c||(c="utf8"),!g.isEncoding(c))throw new TypeError('"encoding" must be a valid string encoding');var d=0|r(b,c);return a=f(a,d),a.write(b,c),a}function m(a,b){var c=0|p(b.length);a=f(a,c);for(var d=0;c>d;d+=1)a[d]=255&b[d];return a}function n(a,b,c,d){// this throws if `array` is not a valid ArrayBuffer
if(b.byteLength,0>c||b.byteLength<c)throw new RangeError("'offset' is out of bounds");if(b.byteLength<c+(d||0))throw new RangeError("'length' is out of bounds");
// Return an augmented `Uint8Array` instance, for best performance
// Fallback: Return an object instance of the Buffer class
return b=void 0===d?new Uint8Array(b,c):new Uint8Array(b,c,d),g.TYPED_ARRAY_SUPPORT?(a=b,a.__proto__=g.prototype):a=m(a,b),a}function o(a,b){if(g.isBuffer(b)){var c=0|p(b.length);return a=f(a,c),0===a.length?a:(b.copy(a,0,0,c),a)}if(b){if("undefined"!=typeof ArrayBuffer&&b.buffer instanceof ArrayBuffer||"length"in b)return"number"!=typeof b.length||X(b.length)?f(a,0):m(a,b);if("Buffer"===b.type&&$(b.data))return m(a,b.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function p(a){
// Note: cannot use `length < kMaxLength` here because that fails when
// length is NaN (which is otherwise coerced to zero.)
if(a>=e())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+e().toString(16)+" bytes");return 0|a}function q(a){// eslint-disable-line eqeqeq
return+a!=a&&(a=0),g.alloc(+a)}function r(a,b){if(g.isBuffer(a))return a.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(a)||a instanceof ArrayBuffer))return a.byteLength;"string"!=typeof a&&(a=""+a);var c=a.length;if(0===c)return 0;for(
// Use a for loop to avoid recursion
var d=!1;;)switch(b){case"ascii":case"binary":
// Deprecated
case"raw":case"raws":return c;case"utf8":case"utf-8":case void 0:return S(a).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*c;case"hex":return c>>>1;case"base64":return V(a).length;default:if(d)return S(a).length;// assume utf8
b=(""+b).toLowerCase(),d=!0}}function s(a,b,c){var d=!1;
// Return early if start > this.length. Done here to prevent potential uint32
// coercion fail below.
if(
// No need to verify that "this.length <= MAX_UINT32" since it's a read-only
// property of a typed array.
// This behaves neither like String nor Uint8Array in that we set start/end
// to their upper/lower bounds if the value passed is out of range.
// undefined is handled specially as per ECMA-262 6th Edition,
// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
(void 0===b||0>b)&&(b=0),b>this.length)return"";if((void 0===c||c>this.length)&&(c=this.length),0>=c)return"";if(c>>>=0,b>>>=0,b>=c)return"";for(a||(a="utf8");;)switch(a){case"hex":return G(this,b,c);case"utf8":case"utf-8":return C(this,b,c);case"ascii":return E(this,b,c);case"binary":return F(this,b,c);case"base64":return B(this,b,c);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return H(this,b,c);default:if(d)throw new TypeError("Unknown encoding: "+a);a=(a+"").toLowerCase(),d=!0}}function t(a,b,c){var d=a[b];a[b]=a[c],a[c]=d}function u(a,b,c,d){function e(a,b){return 1===f?a[b]:a.readUInt16BE(b*f)}var f=1,g=a.length,h=b.length;if(void 0!==d&&(d=String(d).toLowerCase(),"ucs2"===d||"ucs-2"===d||"utf16le"===d||"utf-16le"===d)){if(a.length<2||b.length<2)return-1;f=2,g/=2,h/=2,c/=2}for(var i=-1,j=0;g>c+j;j++)if(e(a,c+j)===e(b,-1===i?0:j-i)){if(-1===i&&(i=j),j-i+1===h)return(c+i)*f}else-1!==i&&(j-=j-i),i=-1;return-1}function v(a,b,c,d){c=Number(c)||0;var e=a.length-c;d?(d=Number(d),d>e&&(d=e)):d=e;
// must be an even number of digits
var f=b.length;if(f%2!==0)throw new Error("Invalid hex string");d>f/2&&(d=f/2);for(var g=0;d>g;g++){var h=parseInt(b.substr(2*g,2),16);if(isNaN(h))return g;a[c+g]=h}return g}function w(a,b,c,d){return W(S(b,a.length-c),a,c,d)}function x(a,b,c,d){return W(T(b),a,c,d)}function y(a,b,c,d){return x(a,b,c,d)}function z(a,b,c,d){return W(V(b),a,c,d)}function A(a,b,c,d){return W(U(b,a.length-c),a,c,d)}function B(a,b,c){return 0===b&&c===a.length?Y.fromByteArray(a):Y.fromByteArray(a.slice(b,c))}function C(a,b,c){c=Math.min(a.length,c);for(var d=[],e=b;c>e;){var f=a[e],g=null,h=f>239?4:f>223?3:f>191?2:1;if(c>=e+h){var i,j,k,l;switch(h){case 1:128>f&&(g=f);break;case 2:i=a[e+1],128===(192&i)&&(l=(31&f)<<6|63&i,l>127&&(g=l));break;case 3:i=a[e+1],j=a[e+2],128===(192&i)&&128===(192&j)&&(l=(15&f)<<12|(63&i)<<6|63&j,l>2047&&(55296>l||l>57343)&&(g=l));break;case 4:i=a[e+1],j=a[e+2],k=a[e+3],128===(192&i)&&128===(192&j)&&128===(192&k)&&(l=(15&f)<<18|(63&i)<<12|(63&j)<<6|63&k,l>65535&&1114112>l&&(g=l))}}null===g?(g=65533,h=1):g>65535&&(g-=65536,d.push(g>>>10&1023|55296),g=56320|1023&g),d.push(g),e+=h}return D(d)}function D(a){var b=a.length;if(_>=b)return String.fromCharCode.apply(String,a);for(
// Decode in chunks to avoid "call stack size exceeded".
var c="",d=0;b>d;)c+=String.fromCharCode.apply(String,a.slice(d,d+=_));return c}function E(a,b,c){var d="";c=Math.min(a.length,c);for(var e=b;c>e;e++)d+=String.fromCharCode(127&a[e]);return d}function F(a,b,c){var d="";c=Math.min(a.length,c);for(var e=b;c>e;e++)d+=String.fromCharCode(a[e]);return d}function G(a,b,c){var d=a.length;(!b||0>b)&&(b=0),(!c||0>c||c>d)&&(c=d);for(var e="",f=b;c>f;f++)e+=R(a[f]);return e}function H(a,b,c){for(var d=a.slice(b,c),e="",f=0;f<d.length;f+=2)e+=String.fromCharCode(d[f]+256*d[f+1]);return e}/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function I(a,b,c){if(a%1!==0||0>a)throw new RangeError("offset is not uint");if(a+b>c)throw new RangeError("Trying to access beyond buffer length")}function J(a,b,c,d,e,f){if(!g.isBuffer(a))throw new TypeError('"buffer" argument must be a Buffer instance');if(b>e||f>b)throw new RangeError('"value" argument is out of bounds');if(c+d>a.length)throw new RangeError("Index out of range")}function K(a,b,c,d){0>b&&(b=65535+b+1);for(var e=0,f=Math.min(a.length-c,2);f>e;e++)a[c+e]=(b&255<<8*(d?e:1-e))>>>8*(d?e:1-e)}function L(a,b,c,d){0>b&&(b=4294967295+b+1);for(var e=0,f=Math.min(a.length-c,4);f>e;e++)a[c+e]=b>>>8*(d?e:3-e)&255}function M(a,b,c,d,e,f){if(c+d>a.length)throw new RangeError("Index out of range");if(0>c)throw new RangeError("Index out of range")}function N(a,b,c,d,e){return e||M(a,b,c,4,3.4028234663852886e38,-3.4028234663852886e38),Z.write(a,b,c,d,23,4),c+4}function O(a,b,c,d,e){return e||M(a,b,c,8,1.7976931348623157e308,-1.7976931348623157e308),Z.write(a,b,c,d,52,8),c+8}function P(a){
// Node converts strings with length < 2 to ''
if(a=Q(a).replace(aa,""),a.length<2)return"";
// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
for(;a.length%4!==0;)a+="=";return a}function Q(a){return a.trim?a.trim():a.replace(/^\s+|\s+$/g,"")}function R(a){return 16>a?"0"+a.toString(16):a.toString(16)}function S(a,b){b=b||1/0;for(var c,d=a.length,e=null,f=[],g=0;d>g;g++){
// is surrogate component
if(c=a.charCodeAt(g),c>55295&&57344>c){
// last char was a lead
if(!e){
// no lead yet
if(c>56319){
// unexpected trail
(b-=3)>-1&&f.push(239,191,189);continue}if(g+1===d){
// unpaired lead
(b-=3)>-1&&f.push(239,191,189);continue}
// valid lead
e=c;continue}
// 2 leads in a row
if(56320>c){(b-=3)>-1&&f.push(239,191,189),e=c;continue}
// valid surrogate pair
c=(e-55296<<10|c-56320)+65536}else e&&(b-=3)>-1&&f.push(239,191,189);
// encode utf8
if(e=null,128>c){if((b-=1)<0)break;f.push(c)}else if(2048>c){if((b-=2)<0)break;f.push(c>>6|192,63&c|128)}else if(65536>c){if((b-=3)<0)break;f.push(c>>12|224,c>>6&63|128,63&c|128)}else{if(!(1114112>c))throw new Error("Invalid code point");if((b-=4)<0)break;f.push(c>>18|240,c>>12&63|128,c>>6&63|128,63&c|128)}}return f}function T(a){for(var b=[],c=0;c<a.length;c++)
// Node's code seems to be doing this and not & 0x7F..
b.push(255&a.charCodeAt(c));return b}function U(a,b){for(var c,d,e,f=[],g=0;g<a.length&&!((b-=2)<0);g++)c=a.charCodeAt(g),d=c>>8,e=c%256,f.push(e),f.push(d);return f}function V(a){return Y.toByteArray(P(a))}function W(a,b,c,d){for(var e=0;d>e&&!(e+c>=b.length||e>=a.length);e++)b[e+c]=a[e];return e}function X(a){return a!==a}var Y=a("base64-js"),Z=a("ieee754"),$=a("isarray");c.Buffer=g,c.SlowBuffer=q,c.INSPECT_MAX_BYTES=50,/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
g.TYPED_ARRAY_SUPPORT=void 0!==b.TYPED_ARRAY_SUPPORT?b.TYPED_ARRAY_SUPPORT:d(),/*
 * Export kMaxLength after typed array support is determined.
 */
c.kMaxLength=e(),g.poolSize=8192,// not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.
g._augment=function(a){return a.__proto__=g.prototype,a},/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
g.from=function(a,b,c){return h(null,a,b,c)},g.TYPED_ARRAY_SUPPORT&&(g.prototype.__proto__=Uint8Array.prototype,g.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&g[Symbol.species]===g&&
// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
Object.defineProperty(g,Symbol.species,{value:null,configurable:!0})),/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
g.alloc=function(a,b,c){return j(null,a,b,c)},/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
g.allocUnsafe=function(a){return k(null,a)},/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
g.allocUnsafeSlow=function(a){return k(null,a)},g.isBuffer=function(a){return!(null==a||!a._isBuffer)},g.compare=function(a,b){if(!g.isBuffer(a)||!g.isBuffer(b))throw new TypeError("Arguments must be Buffers");if(a===b)return 0;for(var c=a.length,d=b.length,e=0,f=Math.min(c,d);f>e;++e)if(a[e]!==b[e]){c=a[e],d=b[e];break}return d>c?-1:c>d?1:0},g.isEncoding=function(a){switch(String(a).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},g.concat=function(a,b){if(!$(a))throw new TypeError('"list" argument must be an Array of Buffers');if(0===a.length)return g.alloc(0);var c;if(void 0===b)for(b=0,c=0;c<a.length;c++)b+=a[c].length;var d=g.allocUnsafe(b),e=0;for(c=0;c<a.length;c++){var f=a[c];if(!g.isBuffer(f))throw new TypeError('"list" argument must be an Array of Buffers');f.copy(d,e),e+=f.length}return d},g.byteLength=r,
// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
g.prototype._isBuffer=!0,g.prototype.swap16=function(){var a=this.length;if(a%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var b=0;a>b;b+=2)t(this,b,b+1);return this},g.prototype.swap32=function(){var a=this.length;if(a%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var b=0;a>b;b+=4)t(this,b,b+3),t(this,b+1,b+2);return this},g.prototype.toString=function(){var a=0|this.length;return 0===a?"":0===arguments.length?C(this,0,a):s.apply(this,arguments)},g.prototype.equals=function(a){if(!g.isBuffer(a))throw new TypeError("Argument must be a Buffer");return this===a?!0:0===g.compare(this,a)},g.prototype.inspect=function(){var a="",b=c.INSPECT_MAX_BYTES;return this.length>0&&(a=this.toString("hex",0,b).match(/.{2}/g).join(" "),this.length>b&&(a+=" ... ")),"<Buffer "+a+">"},g.prototype.compare=function(a,b,c,d,e){if(!g.isBuffer(a))throw new TypeError("Argument must be a Buffer");if(void 0===b&&(b=0),void 0===c&&(c=a?a.length:0),void 0===d&&(d=0),void 0===e&&(e=this.length),0>b||c>a.length||0>d||e>this.length)throw new RangeError("out of range index");if(d>=e&&b>=c)return 0;if(d>=e)return-1;if(b>=c)return 1;if(b>>>=0,c>>>=0,d>>>=0,e>>>=0,this===a)return 0;for(var f=e-d,h=c-b,i=Math.min(f,h),j=this.slice(d,e),k=a.slice(b,c),l=0;i>l;++l)if(j[l]!==k[l]){f=j[l],h=k[l];break}return h>f?-1:f>h?1:0},g.prototype.indexOf=function(a,b,c){if("string"==typeof b?(c=b,b=0):b>2147483647?b=2147483647:-2147483648>b&&(b=-2147483648),b>>=0,0===this.length)return-1;if(b>=this.length)return-1;if(
// Negative offsets start from the end of the buffer
0>b&&(b=Math.max(this.length+b,0)),"string"==typeof a&&(a=g.from(a,c)),g.isBuffer(a))
// special case: looking for empty string/buffer always fails
// special case: looking for empty string/buffer always fails
return 0===a.length?-1:u(this,a,b,c);if("number"==typeof a)return g.TYPED_ARRAY_SUPPORT&&"function"===Uint8Array.prototype.indexOf?Uint8Array.prototype.indexOf.call(this,a,b):u(this,[a],b,c);throw new TypeError("val must be string, number or Buffer")},g.prototype.includes=function(a,b,c){return-1!==this.indexOf(a,b,c)},g.prototype.write=function(a,b,c,d){
// Buffer#write(string)
if(void 0===b)d="utf8",c=this.length,b=0;else if(void 0===c&&"string"==typeof b)d=b,c=this.length,b=0;else{if(!isFinite(b))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");b=0|b,isFinite(c)?(c=0|c,void 0===d&&(d="utf8")):(d=c,c=void 0)}var e=this.length-b;if((void 0===c||c>e)&&(c=e),a.length>0&&(0>c||0>b)||b>this.length)throw new RangeError("Attempt to write outside buffer bounds");d||(d="utf8");for(var f=!1;;)switch(d){case"hex":return v(this,a,b,c);case"utf8":case"utf-8":return w(this,a,b,c);case"ascii":return x(this,a,b,c);case"binary":return y(this,a,b,c);case"base64":
// Warning: maxLength not taken into account in base64Write
return z(this,a,b,c);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return A(this,a,b,c);default:if(f)throw new TypeError("Unknown encoding: "+d);d=(""+d).toLowerCase(),f=!0}},g.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var _=4096;g.prototype.slice=function(a,b){var c=this.length;a=~~a,b=void 0===b?c:~~b,0>a?(a+=c,0>a&&(a=0)):a>c&&(a=c),0>b?(b+=c,0>b&&(b=0)):b>c&&(b=c),a>b&&(b=a);var d;if(g.TYPED_ARRAY_SUPPORT)d=this.subarray(a,b),d.__proto__=g.prototype;else{var e=b-a;d=new g(e,void 0);for(var f=0;e>f;f++)d[f]=this[f+a]}return d},g.prototype.readUIntLE=function(a,b,c){a=0|a,b=0|b,c||I(a,b,this.length);for(var d=this[a],e=1,f=0;++f<b&&(e*=256);)d+=this[a+f]*e;return d},g.prototype.readUIntBE=function(a,b,c){a=0|a,b=0|b,c||I(a,b,this.length);for(var d=this[a+--b],e=1;b>0&&(e*=256);)d+=this[a+--b]*e;return d},g.prototype.readUInt8=function(a,b){return b||I(a,1,this.length),this[a]},g.prototype.readUInt16LE=function(a,b){return b||I(a,2,this.length),this[a]|this[a+1]<<8},g.prototype.readUInt16BE=function(a,b){return b||I(a,2,this.length),this[a]<<8|this[a+1]},g.prototype.readUInt32LE=function(a,b){return b||I(a,4,this.length),(this[a]|this[a+1]<<8|this[a+2]<<16)+16777216*this[a+3]},g.prototype.readUInt32BE=function(a,b){return b||I(a,4,this.length),16777216*this[a]+(this[a+1]<<16|this[a+2]<<8|this[a+3])},g.prototype.readIntLE=function(a,b,c){a=0|a,b=0|b,c||I(a,b,this.length);for(var d=this[a],e=1,f=0;++f<b&&(e*=256);)d+=this[a+f]*e;return e*=128,d>=e&&(d-=Math.pow(2,8*b)),d},g.prototype.readIntBE=function(a,b,c){a=0|a,b=0|b,c||I(a,b,this.length);for(var d=b,e=1,f=this[a+--d];d>0&&(e*=256);)f+=this[a+--d]*e;return e*=128,f>=e&&(f-=Math.pow(2,8*b)),f},g.prototype.readInt8=function(a,b){return b||I(a,1,this.length),128&this[a]?-1*(255-this[a]+1):this[a]},g.prototype.readInt16LE=function(a,b){b||I(a,2,this.length);var c=this[a]|this[a+1]<<8;return 32768&c?4294901760|c:c},g.prototype.readInt16BE=function(a,b){b||I(a,2,this.length);var c=this[a+1]|this[a]<<8;return 32768&c?4294901760|c:c},g.prototype.readInt32LE=function(a,b){return b||I(a,4,this.length),this[a]|this[a+1]<<8|this[a+2]<<16|this[a+3]<<24},g.prototype.readInt32BE=function(a,b){return b||I(a,4,this.length),this[a]<<24|this[a+1]<<16|this[a+2]<<8|this[a+3]},g.prototype.readFloatLE=function(a,b){return b||I(a,4,this.length),Z.read(this,a,!0,23,4)},g.prototype.readFloatBE=function(a,b){return b||I(a,4,this.length),Z.read(this,a,!1,23,4)},g.prototype.readDoubleLE=function(a,b){return b||I(a,8,this.length),Z.read(this,a,!0,52,8)},g.prototype.readDoubleBE=function(a,b){return b||I(a,8,this.length),Z.read(this,a,!1,52,8)},g.prototype.writeUIntLE=function(a,b,c,d){if(a=+a,b=0|b,c=0|c,!d){var e=Math.pow(2,8*c)-1;J(this,a,b,c,e,0)}var f=1,g=0;for(this[b]=255&a;++g<c&&(f*=256);)this[b+g]=a/f&255;return b+c},g.prototype.writeUIntBE=function(a,b,c,d){if(a=+a,b=0|b,c=0|c,!d){var e=Math.pow(2,8*c)-1;J(this,a,b,c,e,0)}var f=c-1,g=1;for(this[b+f]=255&a;--f>=0&&(g*=256);)this[b+f]=a/g&255;return b+c},g.prototype.writeUInt8=function(a,b,c){return a=+a,b=0|b,c||J(this,a,b,1,255,0),g.TYPED_ARRAY_SUPPORT||(a=Math.floor(a)),this[b]=255&a,b+1},g.prototype.writeUInt16LE=function(a,b,c){return a=+a,b=0|b,c||J(this,a,b,2,65535,0),g.TYPED_ARRAY_SUPPORT?(this[b]=255&a,this[b+1]=a>>>8):K(this,a,b,!0),b+2},g.prototype.writeUInt16BE=function(a,b,c){return a=+a,b=0|b,c||J(this,a,b,2,65535,0),g.TYPED_ARRAY_SUPPORT?(this[b]=a>>>8,this[b+1]=255&a):K(this,a,b,!1),b+2},g.prototype.writeUInt32LE=function(a,b,c){return a=+a,b=0|b,c||J(this,a,b,4,4294967295,0),g.TYPED_ARRAY_SUPPORT?(this[b+3]=a>>>24,this[b+2]=a>>>16,this[b+1]=a>>>8,this[b]=255&a):L(this,a,b,!0),b+4},g.prototype.writeUInt32BE=function(a,b,c){return a=+a,b=0|b,c||J(this,a,b,4,4294967295,0),g.TYPED_ARRAY_SUPPORT?(this[b]=a>>>24,this[b+1]=a>>>16,this[b+2]=a>>>8,this[b+3]=255&a):L(this,a,b,!1),b+4},g.prototype.writeIntLE=function(a,b,c,d){if(a=+a,b=0|b,!d){var e=Math.pow(2,8*c-1);J(this,a,b,c,e-1,-e)}var f=0,g=1,h=0;for(this[b]=255&a;++f<c&&(g*=256);)0>a&&0===h&&0!==this[b+f-1]&&(h=1),this[b+f]=(a/g>>0)-h&255;return b+c},g.prototype.writeIntBE=function(a,b,c,d){if(a=+a,b=0|b,!d){var e=Math.pow(2,8*c-1);J(this,a,b,c,e-1,-e)}var f=c-1,g=1,h=0;for(this[b+f]=255&a;--f>=0&&(g*=256);)0>a&&0===h&&0!==this[b+f+1]&&(h=1),this[b+f]=(a/g>>0)-h&255;return b+c},g.prototype.writeInt8=function(a,b,c){return a=+a,b=0|b,c||J(this,a,b,1,127,-128),g.TYPED_ARRAY_SUPPORT||(a=Math.floor(a)),0>a&&(a=255+a+1),this[b]=255&a,b+1},g.prototype.writeInt16LE=function(a,b,c){return a=+a,b=0|b,c||J(this,a,b,2,32767,-32768),g.TYPED_ARRAY_SUPPORT?(this[b]=255&a,this[b+1]=a>>>8):K(this,a,b,!0),b+2},g.prototype.writeInt16BE=function(a,b,c){return a=+a,b=0|b,c||J(this,a,b,2,32767,-32768),g.TYPED_ARRAY_SUPPORT?(this[b]=a>>>8,this[b+1]=255&a):K(this,a,b,!1),b+2},g.prototype.writeInt32LE=function(a,b,c){return a=+a,b=0|b,c||J(this,a,b,4,2147483647,-2147483648),g.TYPED_ARRAY_SUPPORT?(this[b]=255&a,this[b+1]=a>>>8,this[b+2]=a>>>16,this[b+3]=a>>>24):L(this,a,b,!0),b+4},g.prototype.writeInt32BE=function(a,b,c){return a=+a,b=0|b,c||J(this,a,b,4,2147483647,-2147483648),0>a&&(a=4294967295+a+1),g.TYPED_ARRAY_SUPPORT?(this[b]=a>>>24,this[b+1]=a>>>16,this[b+2]=a>>>8,this[b+3]=255&a):L(this,a,b,!1),b+4},g.prototype.writeFloatLE=function(a,b,c){return N(this,a,b,!0,c)},g.prototype.writeFloatBE=function(a,b,c){return N(this,a,b,!1,c)},g.prototype.writeDoubleLE=function(a,b,c){return O(this,a,b,!0,c)},g.prototype.writeDoubleBE=function(a,b,c){return O(this,a,b,!1,c)},
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
g.prototype.copy=function(a,b,c,d){
// Copy 0 bytes; we're done
if(c||(c=0),d||0===d||(d=this.length),b>=a.length&&(b=a.length),b||(b=0),d>0&&c>d&&(d=c),d===c)return 0;if(0===a.length||0===this.length)return 0;
// Fatal error conditions
if(0>b)throw new RangeError("targetStart out of bounds");if(0>c||c>=this.length)throw new RangeError("sourceStart out of bounds");if(0>d)throw new RangeError("sourceEnd out of bounds");
// Are we oob?
d>this.length&&(d=this.length),a.length-b<d-c&&(d=a.length-b+c);var e,f=d-c;if(this===a&&b>c&&d>b)
// descending copy from end
for(e=f-1;e>=0;e--)a[e+b]=this[e+c];else if(1e3>f||!g.TYPED_ARRAY_SUPPORT)
// ascending copy from start
for(e=0;f>e;e++)a[e+b]=this[e+c];else Uint8Array.prototype.set.call(a,this.subarray(c,c+f),b);return f},
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
g.prototype.fill=function(a,b,c,d){
// Handle string cases:
if("string"==typeof a){if("string"==typeof b?(d=b,b=0,c=this.length):"string"==typeof c&&(d=c,c=this.length),1===a.length){var e=a.charCodeAt(0);256>e&&(a=e)}if(void 0!==d&&"string"!=typeof d)throw new TypeError("encoding must be a string");if("string"==typeof d&&!g.isEncoding(d))throw new TypeError("Unknown encoding: "+d)}else"number"==typeof a&&(a=255&a);
// Invalid ranges are not set to a default, so can range check early.
if(0>b||this.length<b||this.length<c)throw new RangeError("Out of range index");if(b>=c)return this;b>>>=0,c=void 0===c?this.length:c>>>0,a||(a=0);var f;if("number"==typeof a)for(f=b;c>f;f++)this[f]=a;else{var h=g.isBuffer(a)?a:S(new g(a,d).toString()),i=h.length;for(f=0;c-b>f;f++)this[f+b]=h[f%i]}return this};
// HELPER FUNCTIONS
// ================
var aa=/[^+\/0-9A-Za-z-_]/g}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"base64-js":55,ieee754:56,isarray:57}],55:[function(a,b,c){"use strict";function d(){for(var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",b=0,c=a.length;c>b;++b)i[b]=a[b],j[a.charCodeAt(b)]=b;j["-".charCodeAt(0)]=62,j["_".charCodeAt(0)]=63}function e(a){var b,c,d,e,f,g,h=a.length;if(h%4>0)throw new Error("Invalid string. Length must be a multiple of 4");f="="===a[h-2]?2:"="===a[h-1]?1:0,g=new k(3*h/4-f),d=f>0?h-4:h;var i=0;for(b=0,c=0;d>b;b+=4,c+=3)e=j[a.charCodeAt(b)]<<18|j[a.charCodeAt(b+1)]<<12|j[a.charCodeAt(b+2)]<<6|j[a.charCodeAt(b+3)],g[i++]=e>>16&255,g[i++]=e>>8&255,g[i++]=255&e;return 2===f?(e=j[a.charCodeAt(b)]<<2|j[a.charCodeAt(b+1)]>>4,g[i++]=255&e):1===f&&(e=j[a.charCodeAt(b)]<<10|j[a.charCodeAt(b+1)]<<4|j[a.charCodeAt(b+2)]>>2,g[i++]=e>>8&255,g[i++]=255&e),g}function f(a){return i[a>>18&63]+i[a>>12&63]+i[a>>6&63]+i[63&a]}function g(a,b,c){for(var d,e=[],g=b;c>g;g+=3)d=(a[g]<<16)+(a[g+1]<<8)+a[g+2],e.push(f(d));return e.join("")}function h(a){// must be multiple of 3
// go through the array every three bytes, we'll deal with trailing stuff later
for(var b,c=a.length,d=c%3,e="",f=[],h=16383,j=0,k=c-d;k>j;j+=h)f.push(g(a,j,j+h>k?k:j+h));
// pad the end with zeros, but make sure to not forget the extra bytes
return 1===d?(b=a[c-1],e+=i[b>>2],e+=i[b<<4&63],e+="=="):2===d&&(b=(a[c-2]<<8)+a[c-1],e+=i[b>>10],e+=i[b>>4&63],e+=i[b<<2&63],e+="="),f.push(e),f.join("")}c.toByteArray=e,c.fromByteArray=h;var i=[],j=[],k="undefined"!=typeof Uint8Array?Uint8Array:Array;d()},{}],56:[function(a,b,c){c.read=function(a,b,c,d,e){var f,g,h=8*e-d-1,i=(1<<h)-1,j=i>>1,k=-7,l=c?e-1:0,m=c?-1:1,n=a[b+l];for(l+=m,f=n&(1<<-k)-1,n>>=-k,k+=h;k>0;f=256*f+a[b+l],l+=m,k-=8);for(g=f&(1<<-k)-1,f>>=-k,k+=d;k>0;g=256*g+a[b+l],l+=m,k-=8);if(0===f)f=1-j;else{if(f===i)return g?NaN:(n?-1:1)*(1/0);g+=Math.pow(2,d),f-=j}return(n?-1:1)*g*Math.pow(2,f-d)},c.write=function(a,b,c,d,e,f){var g,h,i,j=8*f-e-1,k=(1<<j)-1,l=k>>1,m=23===e?Math.pow(2,-24)-Math.pow(2,-77):0,n=d?0:f-1,o=d?1:-1,p=0>b||0===b&&0>1/b?1:0;for(b=Math.abs(b),isNaN(b)||b===1/0?(h=isNaN(b)?1:0,g=k):(g=Math.floor(Math.log(b)/Math.LN2),b*(i=Math.pow(2,-g))<1&&(g--,i*=2),b+=g+l>=1?m/i:m*Math.pow(2,1-l),b*i>=2&&(g++,i/=2),g+l>=k?(h=0,g=k):g+l>=1?(h=(b*i-1)*Math.pow(2,e),g+=l):(h=b*Math.pow(2,l-1)*Math.pow(2,e),g=0));e>=8;a[c+n]=255&h,n+=o,h/=256,e-=8);for(g=g<<e|h,j+=e;j>0;a[c+n]=255&g,n+=o,g/=256,j-=8);a[c+n-o]|=128*p}},{}],57:[function(a,b,c){var d={}.toString;b.exports=Array.isArray||function(a){return"[object Array]"==d.call(a)}},{}],58:[function(a,b,c){(function(a){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function b(a,b){for(var c=0,d=a.length-1;d>=0;d--){var e=a[d];"."===e?a.splice(d,1):".."===e?(a.splice(d,1),c++):c&&(a.splice(d,1),c--)}
// if the path is allowed to go above the root, restore leading ..s
if(b)for(;c--;c)a.unshift("..");return a}function d(a,b){if(a.filter)return a.filter(b);for(var c=[],d=0;d<a.length;d++)b(a[d],d,a)&&c.push(a[d]);return c}
// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var e=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,f=function(a){return e.exec(a).slice(1)};
// path.resolve([from ...], to)
// posix version
c.resolve=function(){for(var c="",e=!1,f=arguments.length-1;f>=-1&&!e;f--){var g=f>=0?arguments[f]:a.cwd();
// Skip empty and invalid entries
if("string"!=typeof g)throw new TypeError("Arguments to path.resolve must be strings");g&&(c=g+"/"+c,e="/"===g.charAt(0))}
// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)
// Normalize the path
return c=b(d(c.split("/"),function(a){return!!a}),!e).join("/"),(e?"/":"")+c||"."},
// path.normalize(path)
// posix version
c.normalize=function(a){var e=c.isAbsolute(a),f="/"===g(a,-1);
// Normalize the path
return a=b(d(a.split("/"),function(a){return!!a}),!e).join("/"),a||e||(a="."),a&&f&&(a+="/"),(e?"/":"")+a},
// posix version
c.isAbsolute=function(a){return"/"===a.charAt(0)},
// posix version
c.join=function(){var a=Array.prototype.slice.call(arguments,0);return c.normalize(d(a,function(a,b){if("string"!=typeof a)throw new TypeError("Arguments to path.join must be strings");return a}).join("/"))},
// path.relative(from, to)
// posix version
c.relative=function(a,b){function d(a){for(var b=0;b<a.length&&""===a[b];b++);for(var c=a.length-1;c>=0&&""===a[c];c--);return b>c?[]:a.slice(b,c-b+1)}a=c.resolve(a).substr(1),b=c.resolve(b).substr(1);for(var e=d(a.split("/")),f=d(b.split("/")),g=Math.min(e.length,f.length),h=g,i=0;g>i;i++)if(e[i]!==f[i]){h=i;break}for(var j=[],i=h;i<e.length;i++)j.push("..");return j=j.concat(f.slice(h)),j.join("/")},c.sep="/",c.delimiter=":",c.dirname=function(a){var b=f(a),c=b[0],d=b[1];
// It has a dirname, strip trailing slash
return c||d?(d&&(d=d.substr(0,d.length-1)),c+d):"."},c.basename=function(a,b){var c=f(a)[2];
// TODO: make this comparison case-insensitive on windows?
return b&&c.substr(-1*b.length)===b&&(c=c.substr(0,c.length-b.length)),c},c.extname=function(a){return f(a)[3]};
// String.prototype.substr - negative index don't work in IE8
var g="b"==="ab".substr(-1)?function(a,b,c){return a.substr(b,c)}:function(a,b,c){return 0>b&&(b=a.length+b),a.substr(b,c)}}).call(this,a("_process"))},{_process:59}],59:[function(a,b,c){function d(){m&&k&&(m=!1,k.length?l=k.concat(l):n=-1,l.length&&e())}function e(){if(!m){var a=h(d);m=!0;for(var b=l.length;b;){for(k=l,l=[];++n<b;)k&&k[n].run();n=-1,b=l.length}k=null,m=!1,i(a)}}
// v8 likes predictible objects
function f(a,b){this.fun=a,this.array=b}function g(){}
// shim for using process in browser
var h,i,j=b.exports={};!function(){try{h=setTimeout}catch(a){h=function(){throw new Error("setTimeout is not defined")}}try{i=clearTimeout}catch(a){i=function(){throw new Error("clearTimeout is not defined")}}}();var k,l=[],m=!1,n=-1;j.nextTick=function(a){var b=new Array(arguments.length-1);if(arguments.length>1)for(var c=1;c<arguments.length;c++)b[c-1]=arguments[c];l.push(new f(a,b)),1!==l.length||m||h(e,0)},f.prototype.run=function(){this.fun.apply(null,this.array)},j.title="browser",j.browser=!0,j.env={},j.argv=[],j.version="",// empty string to avoid regexp issues
j.versions={},j.on=g,j.addListener=g,j.once=g,j.off=g,j.removeListener=g,j.removeAllListeners=g,j.emit=g,j.binding=function(a){throw new Error("process.binding is not supported")},j.cwd=function(){return"/"},j.chdir=function(a){throw new Error("process.chdir is not supported")},j.umask=function(){return 0}},{}],60:[function(a,b,c){function d(a){"string"==typeof a&&(a={url:a});var b=new XMLHttpRequest,c=a.url,h=a.method||"GET",i=a.data||null,j=a.headers||{},k=d.async;if(!c)throw new TypeError("Must provide a URL");return a.hasOwnProperty("withCredentials")&&(b.withCredentials=a.withCredentials),a.hasOwnProperty("timeout")&&(b.timeout=a.timeout),new Promise(function(l,m){function n(){var c=b.readyState;if(
// If there is a state change handler, call it with the request object and options.
a.stateChange&&a.stateChange(b,a),c===g.DONE)if(b.status>=100&&b.status<300){
// Handle response transformation.
var f=(a.transform||e)(b.responseText,b.getResponseHeader("Content-Type"));
// Call global success handler
d.success(f,b),a.success&&a.success(f,b),
// Resolve deferred Promise
l(f)}else
// Call global error handler
d.error(b),a.error&&a.error(b),
// Reject deferred Promise
m(b)}b.onreadystatechange=n,b.open(h,c,k,a.user,a.password),
// Make sure to add all the headers.
f(b,d.headers),f(b,j),b.send(i)})}function e(a,b){var c=d.transforms[b];return c?c(a):a}function f(a,b){for(var c in b)b.hasOwnProperty(c)&&a.setRequestHeader(c,b[c])}var g={UNSENT:0,// open()has not been called yet.
OPENED:1,// send()has not been called yet.
HEADERS_RECEIVED:2,// send() has been called, and headers and status are available.
LOADING:3,// Downloading; responseText holds partial data.
DONE:4};
// Setup global async to true. ONLY for debugging.
d.async=!0,
// Set default headers
d.headers={},
// Assign transforms to content types
d.transforms={},d.transforms["application/json"]=JSON.parse,
// Global handlers for error and success
d.error=function(){},d.success=function(){},b.exports=d},{}],61:[function(a,b,c){/**
 * Bitimports is a module loader for the browser. It has flexible and powerful
 * processing pipelines that allow you to load your modules the way you want.
 * This module loader supports the System module loading interface for loading
 * modules as well as CJS dependency processing. This combination enables the
 * use of transpilers like [babel]{@link http://babeljs.io/} so that you can
 * write ES6 (and later), write in the browser. [bit-loader]{@link Bitloader}
 *
 * @class
 * @private
 * @augments Bitloader
 */
function d(a){var b=i.merge({},j,a);if(!b.resolve){var c=f.create("resolver",b);b.resolve=c.resolve.bind(c)}if(!b.fetch){var d=f.create("fetcher",b);b.fetch=d.fetch.bind(d)}h.call(this,b),this.plugin("js",{dependency:g}),
// Make this option a bit obtuse - I wanna make it a lil difficult for people to
// enable processing of node_modules since it can be rather difficult to tweak
// configurations to properly excluce modules to be processed.
b.doNotIgnoreNodeModules!==!0&&(this.services.transform.ignore("path",/node_modules\//),this.services.dependency.ignore("path",/node_modules\//))}var e=a("./logger"),f=a("./factory"),g=a("deps-bits"),h=a("bit-loader"),i=a("belty"),j={baseUrl:".",packages:[],paths:{}};
// Setup inheritance.
d.prototype=Object.create(h.prototype),d.prototype.constructor=d,
// Add these contructs to the prototype so that bit import instances can have
// access to them.
/**
 * Global logger instance.
 */
d.prototype.logger=e,/*
 * Module constructor
 */
d.prototype.Module=h.Module,/*
 * Rule matching engine constructor
 */
d.prototype.Rule=h.Rule,/**
 * Bitimports factory
 *
 * @returns {Bitimports} Instance of Bitimports
 */
d.prototype.create=function(a){return new d(a)},/**
 * Method to configure an instance of Bitimports.
 *
 * config applies the configuration settings to `this` instance of Bitimports.
 * It will also create and return a new instance of Bitimports with the
 * configuration settings passed in. The config method is generally your
 * primary way of configuring and creating instances of Bitimports.
 *
 * @param {Object} options - Configuration settings for Bitimports instance.
 *  Please take a look over at [amd resolver]{@link https://github.com/MiguelCastillo/amd-resolver}
 *  for details on the options.
 * @param {string} options.baseUrl - Root URL for resolving modules names.
 * @param {Object} options.paths - A map of module names to module paths.
 *  The resolution pipeline will use the configured paths when loading modules
 *  for the matching names.
 * @param {string[]} options.extensions - List of known extensions. Files with
 *  extensions in this list will not get `.js` appended.
 * @param {string[]} options.packages - List of module names to be treated as packages.
 *  Module names matching items in this list will resolve to URLs `packagename/main.js`.
 *  That is to say that loading a module called `machine` will generate the URL `machine/main.js`.
 * @param {Object[]} options.packages - List of package configuration settings.
 *  Package objects allow you to granuarly configure what URLs are generated when
 *  resolving module names.
 * @param {string} options.packages[].location - Location of the module on disk
 * @param {string} options.packages[].main - File name. Defaults to `main.js`.
 * @param {string} options.packages[].name - Package name. This is what the resolution
 *  matches module names against.
 *
 * @returns {Bitimports} Instance of Bitimports
 */
d.prototype.configure=d.prototype.config=function(a){return this.create(i.merge({},this.settings,{fetch:null,resolve:null},a))},/**
 * `bitimports` is the default instance available in the environtment.
 * Generally speaking, you configure it with the [config]{@link Bitimports#config} method
 * to define how your application needs to be processed.
 *
 * When the bit-imports module is loaded via script tag, which is the more
 * common use case in the browser, `bitimports` is automatically added to the
 * global object.  But since bit-imports is a [UMD]{@link https://github.com/umdjs/umd}
 * module, feel free to load it as an [AMD]{@link https://github.com/amdjs/amdjs-api/wiki/AMD}
 * or [CJS]{@link http://wiki.commonjs.org/wiki/Modules/1.1.1} module.
 *
 *
 * @example
 * <!DOCTYPE html>
 * <html lang="en">
 *   <head>
 *     <script type="text/javascript" src="node_modules/bit-imports/dist/bit-imports.min.js" defer></script>
 *     <script type="text/javascript" src="config.js" defer></script>
 *   </head>
 * </html>
 *
 * @example
 * var System = bitimports
 *  // Configure bitimports
 *  .config({
 *    paths: {
 *      babel: "node_modules/babel-bits/dist/index.min"
 *    }
 *  })
 *  // Setup js pipeline with babel-bits
 *  .plugin("js", {
 *    extensions: ["js"],
 *    transform: {
 *      handler: "babel",
 *      options: {
 *        sourceMap: "inline",
 *        presets: ["es2015"]
 *      }
 *    }
 *  });
 *
 * // Import "main" module.
 * System.import("main");
 *
 * @global
 * @name bitimports
 * @type Bitimports
 * @see {@link Bitimports}
 */
b.exports=new d},{"./factory":62,"./logger":64,belty:9,"bit-loader":23,"deps-bits":52}],62:[function(a,b,c){function d(a,b){f[a]=b}function e(a,b){return new f[a](b)}var f={};b.exports={register:d,create:e}},{}],63:[function(a,b,c){/**
 * @class
 *
 * FileReader that loads files from storage
 */
function d(){this._provider=g}var e=a("./logger").create("bitimports/fetch"),f=a("promjax"),g=null;
// Register method to load file content from storage
g=window.fetch?function(a){return window.fetch(a).then(function(a){return a.text()})}:f,d.prototype.fetch=function(a){function b(a){return{source:a}}return e.log(a.name,a),this._provider(a.path).then(b,e.error)},b.exports=d},{"./logger":64,promjax:60}],64:[function(a,b,c){var d=a("bit-loader");b.exports=d.logger},{"bit-loader":23}],65:[function(a,b,c){function d(a){a=a||{},a.baseUrl=e(a.baseUrl),this._provider=new g(a)}/*
 * This will adjust the baseUrl in the settings so that requests get the absolute
 * url so that browsers can better handle `# sourceURL`.  In chrome for example,
 * the files are added to the developer tools' source tree, which let's you put
 * break points directly from the developer tools.
 */
function e(a){var b="undefined"!=typeof window?window.location.href:"";return g.Url.parser.resolve(b,a||"")}/*
 * Gets the url form the module data if it exists.
 */
function f(a){return a&&a.path||""}var g=a("amd-resolver");d.prototype.resolve=function(a){var b=this._provider.resolve(a.name,f(a.referrer)),c=g.file.parseParts(b.url.href);return b.directory=c.directory,b.path=c.path,b},b.exports=d},{"amd-resolver":3}]},{},[1])(1)});
//# sourceMappingURL=bit-imports.min.js.map